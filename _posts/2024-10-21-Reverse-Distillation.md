



# 通过单类嵌入反向蒸馏进行异常检测

![image-20241021155408038](/assets/blog_res/2024-10-21-Reverse-Distillation.assets/image-20241021155408038.png)



## Motivation

论文针对传统的知识蒸馏的方案提出了一个问题：认为之前的方案容易阻碍异常表现的多样性

1.传统的知识蒸馏teacher和student的网络架构很相似或者几乎相同

2.而且teacher和student的输入流都是一样的

针对这个我的理解是，因为T和S网络相似，尽管T是预训练好的，有一定的泛化能力，而S只是模仿了T学到了重建正常样本的能力，但是不排除S学的非常好，有了和T很接近的能力，导致在推理阶段输入异常样本，S网络也是有很大的可能重建的和T很接近，那么最后的Loss也会比较小，这样对异常检测不利。

而且还有一点就是作者提到传统知识蒸馏中的student网络都要比teacher小，那么这也带来一个问题，就是小网络的重建性能是需要得到质疑的，如果重建能力不是那么好，不管正常还是异常都会产生问题。

针对上面提出的问题，作者提出了一个反转的知识蒸馏方案，将teacher作为encoder，student作为decoder,并且在teacher和student之间加入了一个one-class bottleneck embedding (OCBE) 模块

![Snipaste_2024-10-29_09-28-27](/assets/blog_res/2024-10-21-Reverse-Distillation.assets/Snipaste_2024-10-29_09-28-27.png)

反向蒸馏由异构体系结构组成：一个教师编码器和一个学生解码器。其次，学生解码器不直接将原始数据同时提供给T-S模型

这种设计有两个主要优点：

i）非相似结构。可以将教师编码器视为下采样滤波器，将学生解码器视为上采样滤波器。 “反向结构”避免了无法区分的滤波器引起的混淆。

ii）紧凑嵌入。馈送到学生解码器的低维嵌入作为正常模式恢复的信息瓶颈层（bottleneck）。异常特征可以看作是正常模式上的扰动。紧凑的嵌入有助于防止这种不寻常的扰动传播到学生模型，并因此提高了T-S模型在异常上的表示差异

## 方法

简单记录一下网络用到的方法：

encoder模块使用的是预训练的模型，作者尝试了ResNet、WideResNet作为预训练模型，效果都比较好；

在OCBE模块中，包含了多尺度特征融合模块MFF和一类特征提取模块OCE，使用多尺度融合大多数理由都差不多：低维度的特征包含了很多纹理、边缘等信息，高维度的特征包含了很多语义结构等信息。然后多尺度融合其实也进行了一个压缩特征的作用，去掉冗余的信息（作者提到了信息瓶颈的概念）

对于OCBE模块的作用，我的理解是，作者认为直接把encoder最后一层的激活信息丢给decoder恢复的话，会有很多语义结构上的冗余信息，一方面会导致decoder恢复起来比较困难，另外一方面使得网络难以恢复最关键的信息。所以作者在使用多尺度的基础上，进行了特征的压缩，既有了丰富的信息，也尽量去掉了冗余信息。

KD中的教师模型最后一层如果直接输入给学生网络，那么其中具有高自由度和冗余的特征不利于学生只学习正常特征。其次，最后一层富含语义信息，直接馈送给学生网络不利于低级别特征的重建。

单类瓶颈嵌入（OCBE）模块用于进一步压缩特征空间。OCBE模块包括一个多尺度特征融合（MFF）块（用于聚合特征）和一个单类嵌入（OCE）块（用于保留关键信息）。OCBE模块将多尺度模式进一步压缩到极低维空间，以进行下游正常表示重建。

首先通过3×3的卷积层来下采样浅层特征，然后进行BN和ReLU激活。然后再接1×1卷积、BN和ReLU。


![Snipaste_2024-10-29_09-29-43](/assets/blog_res/2024-10-21-Reverse-Distillation.assets/Snipaste_2024-10-29_09-29-43.png)

从上图可以看到在MFF模块中，网络使用了3x3卷积进行下采样，然后将特征串联起来，在OCE中使用了残差网络的第4个block。

对于decoder模块来说，是一个和teacher对称的模块

## 损失函数

损失函数也是比较常规的，用的是像素间的余弦相似性，

![Snipaste_2024-10-29_09-30-14](/assets/blog_res/2024-10-21-Reverse-Distillation.assets/Snipaste_2024-10-29_09-30-14.png)

对于异常分数这里，结合评论区和代码的理解，论文中是对每一个图片都会记录一个像素级异常分数S_AL，对于图像级的分类，从像素级的分数中选取max(S_AL)的分数作为这张图片的得分，最后取阈值score=MAX(正常样本的max(S_AL))，在推理阶段，得分大于score的就是异常样本。

论文中还有一些细节，比如如何设置decoder、MMF、OCE（这里用了resnet结构的第4层bottleneck，stride=2），可以结合代码具体看看。

### 实验

MVTec：AUROC：98.5

pixel AUROC：97.8；PRO：93.9

作者还进行了**单类新颖性检测**的实验，结果如下：

![image-20241021155440878-17294972830672](/assets/blog_res/2024-10-21-Reverse-Distillation.assets/image-20241021155440878-17294972830672.png)
