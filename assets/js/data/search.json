[ { "title": "协程简介", "url": "/posts/%E5%8D%8F%E7%A8%8B%E5%92%8Clibco/", "categories": "笔记", "tags": "计算机基础", "date": "2022-06-25 13:02:00 +0000", "snippet": "基本概念协程 在这里略过进程和线程的基本概念，默认读者了解协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源（用户态和内核态的切换），因此协程的开销远远小于线程的开销。 协程本质上就是用户态线程，将调度的代码在用户态重新实现。因为子程序切换不是线程切换而是由程序自身控制，没有线程切换的开销，所以协程有极高的执行效率。协程通常是纯软件实现的多任务，与CPU和操作系统通常没有关系，跨平台，跨体系架构。 协程在执行过程中，可以调用别的协程自己则中途退出执行，之后又从调用别的协程的地方恢复执行。这有点像操作系统的线程，执行过程中可能被挂起，让位于别的线程执行，稍后又从挂起的地方恢复执行。 对于线程而言，其上下文存储在内核栈上。线程的上下文切换必须先进入内核态并切换上下文, 这就造成了调度开销。线程的结构体存在于内核中，在pthread_create时需要进入内核态，频繁创建开销大。协程的优点与缺点优点： 跨平台体系结构 无需线程上下文切换的开销（相比线程切换） 无需原子操作锁定及同步的开销（相比多线程程序） 方便切换控制流，简化编程模型（调用与回调可以在同一个地方写完） 高并发+高扩展性+低成本：高性能CPU可以启用非常多的协程，很适合用于高并发处理。缺点： 无法利用多核资源：协程的本质是个单线程，它不能将一个多核处理器的的多个核同时用上,协程需要和进程配合才能运行在多CPU上。（线程、多核、超线程参见CSAPP第三版1.9.2并发和并行P17）当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序。（https://cloud.tencent.com/developer/article/1684951）   进程 线程 协程 切换者 OS OS 用户 切换时机 根据操作系统自己定义的切换策略 根据操作系统自己定义的切换策略 用户自己的程序决定 切换内容 页全局目录、内核栈、硬件上下文（进程空间相关知识） 内核栈、硬件上下文 硬件上下文 切换内容的保存位置 保存在内核中 保存在内核中 保存于用户自己定义的用户栈或者堆中 切换过程 用户态-内核态-用户态 用户态-内核态-用户态 用户态（无陷入内核态） 切换效率 低 中 高 协程实现相关概念函数栈切换Linux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： 只读段/代码段：只能读，不可写；可执行代码、字符串字面值、只读变量 数据段：已初始化且初值非0全局变量、静态变量的空间 BSS(Block Started Symbol)段：未初始化或初值为0的全局变量和静态局部变量 堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此 文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间 栈：用于维护函数调用的上下文空间；局部变量、函数参数、返回地址等 内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)栈帧栈帧是指为一个函数调用单独分配的那部分栈空间。比如，当运行中的程序调用另一个函数时，就要进入一个新的栈帧，原来函数的栈帧称为调用者函数的帧，新的栈帧称为被调用函数的帧（当前帧）。被调用的函数运行结束后当前帧全部回收，回到调用者的帧。栈帧的详细结构如下图所示：函数A调用函数B，A就是调用者函数，B就是被调用函数（参考CSAPP 3.7 过程【3.7.1 运行时栈】P164）函数调用时的esp/ebp当进行函数调用的时候，除了将参数挨个入栈、将返回地址（指明当B返回的时候，要从A程序的哪个位置(程序指令在内存中的地址)继续执行，参见程序计数器相关：https://www.zhihu.com/question/22609253）入栈以外，接下来就是移动esp和ebp指针void func A(){ int x = 1;\tB(); int y = 2;\t// 调用完函数，需要执行的下一条语句。该语句在程序运行时，最终变成机器可以执行的指令，该指令存储在内存中的位置就是返回地址。那么到底所谓的该指令长什么样子呢？那就是回到前面说的代码段（Code Segment）的地方，PC程序计数器中的内容就是一个地址，当前执行指令的地址（样子就是CS:IP，Code Segment:Instruction Pointer），代码段（CS）里面的内容是机器(指代处理器)都能通过使用指令集来看懂的指令，是二进制内容！ return;}void func B(){ int z = 3; return;}参考资料：1、CS:IP是什么？2、程序计数器https://www.zhihu.com/question/226092533、What does the text segment in a program’s memory refer to? 将调用者(A)函数的ebp入栈(push ebp)，然后将调用者函数的栈顶指针ESP赋值给被调函数的EBP(作为被调函数的栈底,move ebp,esp)，之后便可以将局部变量push的方式入栈了，结果如下图所示：此时,EBP寄存器处于一个非常重要的位置,该寄存器中存放着一个地址(原EBP入栈后的栈顶),以该地址为基准,向上(栈底方向)能获取返回地址、参数值,向下(栈顶方向)能获取函数的局部变量值,而该地址处又存放着上一层函数调用时的EBP值;一般规律,SS:[ebp+4]处为被调函数的返回地址,SS:[EBP+8]处为传递给被调函数的第一个参数(最后一个入栈的参数,此处假设其占用4字节内存)的值,SS:[EBP-4]处为被调函数中的第一个局部变量,SS:[EBP]处为上一层EBP值;由于EBP中的地址处总是”上一层函数调用时的EBP值”,而在每一层函数调用中,都能通过当时的EBP值”向上(栈底方向)能获取返回地址、参数值,向下(栈顶方向)能获取被调函数的局部变量值”;如此递归，就形成了函数调用栈；函数调用栈不管是较早的帧，还是调用者的帧，还是当前帧，它们的结构是完全一样的，因为每个帧都是基于一个函数，帧随着函数的生命周期产生、发展和消亡。这里用到了两个寄存器，%ebp是帧指针（帧寄存器），它总是指向当前帧的底部；%esp是栈指针（栈寄存器），它总是指向当前帧的顶部。这两个寄存器用来定位当前帧中的所有空间，在后面的代码中将会经常出现。编译器需要根据IA32指令集的规则小心翼翼地调整这两个寄存器的值，一旦出错，参数传递、函数返回都可能出现问题。int caller(){ int arg1 = 534; int arg2 = 1057; int sum = swap_add(&amp;arg1, &amp;arg2); int diff = arg1 - arg2; return sum * diff;}int swap_add(int *xp, int *yp){ int x = *xp; int y = *yp; *xp = y; *yp = x; return x + y;} 首先，程序从caller开始运行，为了详细说明每一行程序都做了什么操作，我们将caller函数的C代码编译成汇编码，并给每一句附上注释：1 caller:2 pushl %ebp # 将caller函数的上一层函数的ebp位置进行保存3 movl %esp, %ebp # 将这时候的esp位置设置为ebp位置（栈帧底部）4 subl $24, %esp # 分配 24 bytes 空间（后续介绍）5 movl $534, -4(%ebp) # 分配局部变量1为5346 movl $1057, -8(%ebp) # 分配局部变量2为10577 leal -8(%ebp), %eax # 计算&amp;arg2并放入%eax8 movl %eax, 4(%esp) # 将&amp;arg2放入参数2位置(从右往左放入)9 leal -4(%ebp), %eax # 计算&amp;arg1并放入%eax10 movl %eax, (%esp) # 将&amp;arg1放入参数1位置(从右往左放入)11 call swap_add # 调用swap_add函数12 ...第3行执行完如下：第10行执行完如下：来解释栈帧为什么申请了24字节的空间。在现代处理器中，栈帧必须16字节对齐，就是说栈底和栈顶的地址必须是16的整数倍。至于为什么会有这样的要求，请查看文章《联合、数据对齐和缓冲区溢出攻击》。现在，既然要求是16的整数倍，24字节肯定是不够的，仔细观察栈帧除了这额外申请的24字节空间外，还有最初压栈的%ebp寄存器占用4字节，以及调用子函数前保存的返回地址占用4字节，加起来正好32字节，实现了16字节对齐。如下图所示。1 caller:2 pushl %ebp # 将caller函数的上一层函数的ebp位置进行保存3 movl %esp, %ebp # 将这时候的esp位置设置为ebp位置（栈帧底部）4 subl $24, %esp # 分配 24 bytes 空间（后续介绍）5 movl $534, -4(%ebp) # 分配局部变量1为5346 movl $1057, -8(%ebp) # 分配局部变量2为10577 leal -8(%ebp), %eax # 计算&amp;arg2并放入%eax8 movl %eax, 4(%esp) # 将&amp;arg2放入参数2位置(从右往左放入)9 leal -4(%ebp), %eax # 计算&amp;arg1并放入%eax10 movl %eax, (%esp) # 将&amp;arg1放入参数1位置(从右往左放入)11 call swap_add # 调用swap_add函数12 ...接下来执行第11行： call swap_addcall指令不仅仅是跳转到子函数的位置，而且还要为子函数的正确返回做准备。事实上，call指令可以分为两步，第一步将当前程序段的下一行代码的地址入栈，第二步才是跳转到子函数的代码段，相当于如下两行指令pushl [当执行结束返回到caller时，接下来需要执行的代码的地址]jmp swap_add在上面的代码中就是 int diff = arg1 - arg2; 这段代码的地址。int swap_add(int *xp, int *yp){ int x = *xp; int y = *yp; *xp = y; *yp = x; return x + y;} int caller(){ int arg1 = 534; int arg2 = 1057; int sum = swap_add(&amp;arg1, &amp;arg2); int diff = arg1 - arg2; return sum * diff;}栈帧如下：接下来看swap_add函数的汇编代码：也就是被调函数1 swap_add:2 pushl %ebp # 保存旧的%ebp，即caller的%ebp3 movl %esp, %ebp # 将这时的%esp设置为%ebp，也叫设置为swap_add函数的ebp4 pushl %ebx # 将%ebx入栈保存5 movl 8(%ebp), %edx #Get xp6 movl 12(%ebp), %ecx #Get yp7 movl (%edx), %ebx #Get x8 movl (%ecx), %eax #Get y9 movl %eax, (%edx) #Store y at xp10 movl %ebx, (%ecx) #Store x at yp11 addl %ebx, %eax #Return value = x+y12 popl %ebx #Restore %ebx13 popl %ebp #Restore %ebp14 ret #Return2-4行为预处理部分，和前面分析过的预处理相似，保存旧的帧指针，设置新的帧指针，但多了一步：将第4行的%ebx寄存器入栈。该操作是为了保存%ebx寄存器的值，以便在函数结束时恢复原值，即第12行的popl %ebx。知识点：寄存器的使用惯例为什么caller中没有保存%ebx而swap_add中却保存了呢？这涉及到IA32指令集的寄存器使用惯例，这个惯例保证了函数调用时寄存器的值不会丢失或紊乱。 %eax、%edx和%ecx称为调用者保存寄存器，被调用者使用这三个寄存器时不必担心它们原来的值有没有保存下来，这是调用者自己应该负责的事情。 %ebx、%esi和%edi称为被调用者保存寄存器，被调用者如果想要使用它们，必须在开始时保存它们的值并在结束时恢复它们的值，一般通过压栈和出栈来实现。这就可以解释我们的疑问了。由于%ebx是被调用者保存寄存器，因此在swap_add中我们通过pushl %ebx和popl %ebx来保存该寄存器的值在函数执行前后不变。int swap_add(int *xp, int *yp){ int x = *xp; int y = *yp; *xp = y; *yp = x; return x + y;}1 swap_add:2 pushl %ebp # 保存旧的%ebp，即caller的%ebp3 movl %esp, %ebp # 将这时的%esp设置为%ebp，也叫设置为swap_add函数的ebp4 pushl %ebx # 将%ebx入栈保存5 movl 8(%ebp), %edx #Get xp6 movl 12(%ebp), %ecx #Get yp7 movl (%edx), %ebx #Get x8 movl (%ecx), %eax #Get y9 movl %eax, (%edx) #Store y at xp10 movl %ebx, (%ecx) #Store x at yp11 addl %ebx, %eax #Return value = x+y12 popl %ebx #Restore %ebx13 popl %ebp #Restore %ebp14 ret #Return5~11行为swap_add函数的功能实现代码。略过不看，这里没有进行栈的push操作。12~14行为结束代码，做一些函数的收尾工作。11行执行结束的函数栈帧如下：首先第12行恢复%ebx寄存器的值，接着第13行恢复%ebp寄存器的值，最后ret返回。而ret指令也分为两步，第一步取出当前栈顶的值（即int diff = arg1 - arg2;这段代码的地址），第二步将这个值作为跳转指令的地址跳转，相当于下面两行代码：popl %edxjmp %edxret之后将会执行call swap_add指令紧跟着的下一行代码。接下来给出caller函数剩下的汇编代码：（即call swap_add后的代码）11 call swap_add12 movl -4(%ebp), %edx13 subl -8(%ebp), %edx14 imull %edx, %eax15 leave16 ret12~14行都是在完成之后的一些运算而已，略过。但是15行用了一个没见过的指令leave，这又是什么意思呢？我们来分析一下，这段代码和swap_add最后三行代码相比，少了两句popl %ebx和popl %ebp，多了一句leave。首先，popl %ebx不用考虑了，因为在caller的开头并没有pushl %ebx，因此也就没必要popl %ebx。那么我猜测leave是否替代了popl %ebp的功能呢？之所以这样猜测，首先我们得弄懂popl %ebp到底是什么功能。很简单，每个函数结束前需要将栈恢复到函数调用前的样子，其实就是恢复两个指针——帧指针和栈指针的位置。popl %ebp的作用就是恢复帧指针的位置。而栈指针%esp呢？似乎没有看到哪条指令把它恢复。让我们再仔细捋一遍。先看子函数swap_add运行过程中的栈指针。使栈指针变化的只有四条语句，2、4行的pushl指令和12、13行的popl指令，而且两对指令对栈指针的影响正好对消，于是栈指针在函数结束时已经回到了最初的位置，因此根本不需要额外的调整。再考虑caller函数，与swap_add不同的地方在于第4行申请了24字节的栈空间，即手动将%esp寄存器的值减去了24。这就导致函数结束时栈指针无法回到最初的位置，需要我们手动将它恢复，leave指令就是这个作用。该指令相当于下面两条指令的合成：movl %ebp, %esp # 手动恢复栈顶指针位置popl %ebp # 恢复上一个函数的ebp的位置有栈协程 协程切换时主要保存的上下文环境就是指寄存器的内容、栈帧的内容。独立栈独立栈指的是在所有协程运行的过程中，它们用的栈帧是自己的栈，这块栈的地址的内容不会让其他协程进行读写。缺点：独立栈往往会更加的浪费内存。因为，我们需要为每一个协程预先分配一个栈空间，但是问题是协程不一定会用完这个栈空间，而那些多出来的栈空间就是被浪费掉了的。而且空间太小也会有爆栈的隐患。优点：每次切换协程的时候，不需要对栈进行拷贝。（相比于共享栈）共享栈共享栈指的是在所有协程运行的过程中，它们用的任务栈是同一个栈。优点：可以更加的节省内存。因为，我们只需要让协程使用这个共享的栈即可，然后，当协程挂起的时候，依据当前协程使用的栈空间大小来分配内存备份协程的栈内容。缺点：就会使得每次换入和换出协程的时候，都要进行协程的栈数据的拷贝。协程切换libco使用：https://blog.csdn.net/arbboter/article/details/101375476协程环境数量对应关系来说，协程之于线程，相当于线程之于进程，一个进程可以包含多个线程，而一个线程中可以包含多个协程。以libco为例，线程中用于管理协程的结构体为stCoRoutineEnv_t（环境），它在该线程中第一个协程创建的时候进行初始化。每个线程中都只有一个stCoRoutineEnv_t实例，线程可以通过该stCoRoutineEnv_t实例了解现在有哪些协程，哪个协程正在运行，以及下一个运行的协程是哪个。简单来说，一个线程对应一个stCoRoutineEnv_t结构，一个stCoRoutineEnv_t结构对应多个协程。在第一次创建协程的时候会对stCoRoutineEnv_t进行初始化，并自动将当前线程执行的上下文空间为主协程，然后再创建真正的用户自己定义的协程。struct stCoRoutineEnv_t{ stCoRoutine_t *pCallStack[ 128 ]; // 保存当前栈中的协程，上限128个 int iCallStackSize; // 表示当前在运行的协程的下一个位置，即cur_co_runtine_index + 1 stCoEpoll_t *pEpoll; //用于协程时间片切换 //for copy stack log lastco and nextco stCoRoutine_t* pending_co; stCoRoutine_t* occupy_co;};协程核心切换实现首先是一个协程对应的它的上下文coctx_t的初始化如下：int coctx_make( coctx_t *ctx,coctx_pfn_t pfn,const void *s,const void *s1 ){ //make room for coctx_param // 获取(栈顶 - param size)的指针，栈顶和sp指针之间用于保存函数参数 char *sp = ctx-&gt;ss_sp + ctx-&gt;ss_size - sizeof(coctx_param_t); sp = (char*)((unsigned long)sp &amp; -16L); // 用于16位对齐 // 将参数填入到param中 coctx_param_t* param = (coctx_param_t*)sp ; param-&gt;s1 = s; param-&gt;s2 = s1; memset(ctx-&gt;regs, 0, sizeof(ctx-&gt;regs)); // 为什么要 - sizeof(void*)呢？ 用于保存返回地址 ctx-&gt;regs[ kESP ] = (char*)(sp) - sizeof(void*); ctx-&gt;regs[ kEIP ] = (char*)pfn; return 0;}这段代码主要是做了什么呢？ 先给coctx_pfn_t函数预留2个参数的大小，并4位地址对齐 将参数填入到预存的参数中 regs[kEIP]中保存了pfn的地址，regs[kESP]中则保存了栈顶指针 - 4个字节的大小的地址。这预留的4个字节用于保存return address。现在我们来看下协程切换的核心 coctx_swap，这个函数是使用汇编实现的。主要分为保存当前栈空间上下文的寄存器，并写入即将到来的栈空间上下文的寄存器两个步骤。先看一下执行汇编程序前的栈帧情况。esp寄存器指向return address。//----- --------// 32 bit// | regs[0]: ret |// | regs[1]: ebx |// | regs[2]: ecx |// | regs[3]: edx |// | regs[4]: edi |// | regs[5]: esi |// | regs[6]: ebp |// | regs[7]: eax | = espcoctx_swap:1 leal 4(%esp), %eax // eax = esp + 4 保存co_swap栈空间的cur_ctx的地址到eax2 movl 4(%esp), %esp // esp = *(esp+4) = &amp;cur_ctx 将cur_ctx这个地址赋值给esp。3 leal 32(%esp), %esp // parm a : &amp;regs[7] + sizeof(void*) // esp=&amp;reg[7]+sizeof(void*) 移动esp的位置，为增加 // 为后续pushl的时候esp从高地址到低地址移动准备4 pushl %eax // cur_ctx-&gt;regs[ESP] = %eax = returnAddress + 4 5 pushl %ebp // cur_ctx-&gt;regs[EBX] = %ebp6 pushl %esi // cur_ctx-&gt;regs[ESI] = %esi7 pushl %edi // cur_ctx-&gt;regs[EDI] = %edi8 pushl %edx // cur_ctx-&gt;regs[EDX] = %edx9 pushl %ecx // cur_ctx-&gt;regs[ECX] = %ecx10 pushl %ebx // cur_ctx-&gt;regs[EBX] = %ebx11 pushl -4(%eax) // cur_ctx-&gt;regs[EIP] = return address 保存return address1、其中的cur_ctx是一个堆的地址，里面的内容如下：// 栈切换的时候需要保存的寄存器空间struct coctx_t{#if defined(__i386__) void *regs[ 8 ];#else void *regs[ 14 ];#endif size_t ss_size; char *ss_sp; };2、执行完第2句后，如下：3、执行完第3句后，如下：4、然后就是pushl的过程，通过该指令，esp向上移动，挨个保存寄存器内容。下面是恢复pend_ctx中的寄存器信息到cpu寄存器中 movl 4(%eax), %esp //parm b -&gt; &amp;regs[0] // esp=&amp;pend_ctx 同样的，将pending_ctx的esp弄过去 popl %eax //%eax= pend_ctx-&gt;regs[EIP] = pfunc_t地址，通过popl就是反向的操作 \t\t // popl本身就是低地址到高地址，所以不需要提前移动esp的位置 popl %ebx //%ebx = pend_ctx-&gt;regs[EBX] popl %ecx //%ecx = pend_ctx-&gt;regs[ECX] popl %edx //%edx = pend_ctx-&gt;regs[EDX] popl %edi //%edi = pend_ctx-&gt;regs[EDI] popl %esi //%esi = pend_ctx-&gt;regs[ESI] popl %ebp //%ebp = pend_ctx-&gt;regs[EBP] popl %esp //%ebp = pend_ctx-&gt;regs[ESP] 即 (char*) sp - sizeof(void*) pushl %eax //set ret func addr // return address = %eax = pfunc_t地址 xorl %eax, %eax ret // popl %eip 即跳转到pfunc_t地址执行汇编栈帧切换时的注意事项libco里面的swap函数里面大量用到push(pushl)和pop指令（如下所示），然而在一些其他的协程库里面的swap函数却使用大量的mov指令而非push/pop指令，为什么？coctx_swap:1 leal 4(%esp), %eax // eax = esp + 4 保存co_swap栈空间的cur_ctx的地址到eax2 movl 4(%esp), %esp // esp = *(esp+4) = &amp;cur_ctx 将cur_ctx这个地址赋值给esp。3 leal 32(%esp), %esp // parm a : &amp;regs[7] + sizeof(void*) // esp=&amp;reg[7]+sizeof(void*) 移动esp的位置，为增加 // 为后续pushl的时候esp从高地址到低地址移动准备4 pushl %eax // cur_ctx-&gt;regs[ESP] = %eax = returnAddress + 4 5 pushl %ebp // cur_ctx-&gt;regs[EBX] = %ebp6 pushl %esi // cur_ctx-&gt;regs[ESI] = %esi7 pushl %edi // cur_ctx-&gt;regs[EDI] = %edi8 pushl %edx // cur_ctx-&gt;regs[EDX] = %edx9 pushl %ecx // cur_ctx-&gt;regs[ECX] = %ecx10 pushl %ebx // cur_ctx-&gt;regs[EBX] = %ebx11 pushl -4(%eax) // cur_ctx-&gt;regs[EIP] = return address 保存return address原因：栈指针的使用方式违反Sys V ABI约定注：应用程序二进制接口（Application Binary Interface，ABI） The end of the input argument area shall be aligned on a 16 (32 or 64, if __m256 or __m512 is passed on stack) byte boundary. In other words, the value (%esp + 4) is always a multiple of 16 (32 or 64) when control is transferred to the function entry point. The stack pointer, %esp, always points to the end of the latest allocated stack frame. — Intel386-psABI-1.1:2.2.2 The Stack Frame The stack pointer, %rsp, always points to the end of the latest allocated stack frame. — Sys V ABI AMD64 Version 1.0:3.2.2 The Stack Frame不管是i386还是sys V的ABI都提到了The stack pointer, %rsp, always points to the end of the latest allocated stack frame.即用户空间程序的栈指针必须时刻指到运行栈的栈顶，而coctx_swap.S中却使用栈指针直接对位于堆中的数据结构进行寻址内存操作，这违反了ABI约定。而在Linux信号处理手册中可以看到： By default, the signal handler is invoked on the normal process stack. It is possible to arrange that the signal handler uses an alternate stack; see sigalstack(2) for a discussion of how to do this and when it might be useful. — man 7 signal : Signal dispositions也就是说，用pop方式实现的汇编代码，在有一个时刻出现了esp并不在栈顶的情况，要理解这一点，必须把ebp和esp绑定起来看，即esp在下图所示的时刻和ebp变得“毫无对应关系”，这会导致严重的后果。比如说此时用户态收到信号进入内核态，如果信号处理的时候使用了该esp指针，然而该esp指针的push操作仅仅只能维持sizeof(struct coctx_t)大小，显然很可能会出现问题，因为在正常情况下，esp的push时所在的栈空间都是远大于sizeof(struct coctx_t)的（即使使用共享栈的情况下）。当然查了相关资料后了解到libco内部版本早已解决了这个问题，只是在开源版本里面仍然保留了这个bug。协程上层管理了解了协程的实现原理之后，上层管理可以自己选择自己喜欢的方式，除了直接选择使用共享栈和独立栈的方式以外，甚至可以通过判断栈空间的大小来比较灵活地自动选择模式，以及进行一些具体业务强相关的协程库优化，从而得以让性能提高。协程模块数据结构协程控制块stCoRoutine_tstruct stCoRoutine_t{ stCoRoutineEnv_t *env; // 即协程执行的环境，libco协程一旦创建便跟对应线程绑定了，不支持在不同线程间迁移，这里env即同属于一个线程所有协程的执行环境，包括了当前运行协程、嵌套调用的协程栈，和一个epoll的封装结构。这个结构是跟运行的线程绑定了的，运行在同一个线程上的各协程是共享该结构的，是个全局性的资源。 pfn_co_routine_t pfn; // 实际等待执行的协程函数 void *arg; // 上面协程函数的参数 coctx_t ctx; // 上下文，即ESP、EBP、EIP和其他通用寄存器的值 // 一些状态和标志变量 char cStart; char cEnd; char cIsMain; char cEnableSysHook; char cIsShareStack; void *pvEnv; // 保存程序系统环境变量的指针 //char sRunStack[ 1024 * 128 ]; stStackMem_t* stack_mem; // 协程运行时的栈内存，这个栈内存是固定的 128KB 的大小。 //save stack buffer while confilct on same stack_buffer; // 共享栈模式中使用 char* stack_sp; unsigned int save_size; char* save_buffer; stCoSpec_t aSpec[1024];};// 已经介绍过，略struct stCoRoutineEnv_t{ stCoRoutine_t *pCallStack[ 128 ]; int iCallStackSize; stCoEpoll_t *pEpoll; //for copy stack log lastco and nextco stCoRoutine_t* pending_co; stCoRoutine_t* occupy_co;};// 栈切换的时候需要保存的寄存器空间struct coctx_t{#if defined(__i386__) void *regs[ 8 ];#else void *regs[ 14 ];#endif size_t ss_size; char *ss_sp; }; stack_sp、save_size、save_buffer：这里要提到实现 stackful 协程（与之相对的还有一种stackless协程）的两种技术：Separate coroutine stacks 和 Copying the stack（又叫共享栈）。这三个变量就是用来实现这两种技术的。 实现细节上，前者为每一个协程分配一个单独的、固定大小的栈；而后者则仅为正在运行的协程分配栈内存，当协程被调度切换出去时，就把它实际占用的栈内存 copy 保存到一个单独分配的缓冲区；当被切出去的协程再次调度执行时，再一次 copy 将原来保存的栈内存恢复到那个共享的、固定大小的栈内存空间。 如果是独享栈模式，分配在堆中的一块作为当前协程栈帧的内存 stack_mem，这块内存的默认大小为 128K。 如果是共享栈模式，协程切换的时候，用来拷贝存储当前共享栈内容的 save_buffer，长度为实际的共享栈使用长度。 通常情况下，一个协程实际占用的（从 esp 到栈底）栈空间，相比预分配的这个栈大小（比如 libco 的 128KB）会小得多；这样一来， copying stack 的实现方案所占用的内存便会少很多。当然，协程切换时拷贝内存的开销有些场景下也是很大的。因此两种方案各有利弊，而 libco 则同时实现了两种方案，默认使用前者，也允许用户在创建协程时指定使用共享栈。 创建协程(create)int co_create( stCoRoutine_t **ppco,const stCoRoutineAttr_t *attr,pfn_co_routine_t pfn,void *arg ){ if( !co_get_curr_thread_env() ) { co_init_curr_thread_env(); } stCoRoutine_t *co = co_create_env( co_get_curr_thread_env(), attr, pfn,arg ); *ppco = co; return 0;}调用 co_create 将协程创建出来后，这时候它还没有启动，也即是说我们传递的 routine 函数还没有被调用。实质上，这个函数内部仅仅是分配并初始化 stCoRoutine_t 结构体、设置任务函数指针、分配一段“栈”内存，以及分配和初始化 coctx_t。 ppco：输出参数，co_create内部为新协程分配一个协程控制块，ppco将指向这个分配的协程控制块。 attr：指定要创建协程的属性（栈大小、指向共享栈的指针（使用共享栈模式）） pfn：协程的任务（业务逻辑）函数 arg：传递给任务函数的参数启动协程(resume)void co_resume( stCoRoutine_t *co ){ stCoRoutineEnv_t *env = co-&gt;env; stCoRoutine_t *lpCurrRoutine = env-&gt;pCallStack[ env-&gt;iCallStackSize - 1 ]; if( !co-&gt;cStart ) { coctx_make( &amp;co-&gt;ctx,(coctx_pfn_t)CoRoutineFunc,co,0 ); co-&gt;cStart = 1; } env-&gt;pCallStack[ env-&gt;iCallStackSize++ ] = co; co_swap( lpCurrRoutine, co );}\t在调用 co_create 创建协程返回成功后，便可以调用 co_resume 函数将它启动了。 取当前协程控制块指针，将待启动的协程压入pCallStack栈，然后co_swap切换到指向的新协程上取执行，co_swap不会就此返回，而是要等当前执行的协程主动让出cpu时才会让新的协程切换上下文来执行自己的内容。挂起协程(yield)void co_yield_env( stCoRoutineEnv_t *env ){ stCoRoutine_t *last = env-&gt;pCallStack[ env-&gt;iCallStackSize - 2 ]; stCoRoutine_t *curr = env-&gt;pCallStack[ env-&gt;iCallStackSize - 1 ]; env-&gt;iCallStackSize--; co_swap( curr, last);} 在非对称协程理论，yield 与 resume 是个相对的操作。A 协程 resume 启动了 B 协程，那么只有当 B 协程执行 yield 操作时才会返回到 A 协程。在上一节剖析协程启动函数 co_resume() 时，也提到了该函数内部 co_swap() 会执行被调协程的代码。只有被调协程 yield 让出 CPU，调用者协程的 co_swap() 函数才能返回到原点，即返回到原来 co_resume() 内的位置。 在被调协程要让出 CPU 时，会将它的 stCoRoutine_t 从 pCallStack 弹出，“栈指针” iCallStackSize 减 1，然后 co_swap() 切换 CPU 上下文到原来被挂起的调用者协程恢复执行。这里“被挂起的调用者协程”，即是调用者 co_resume() 中切换 CPU 上下文被挂起的那个协程。 同一个线程上所有协程是共享一个 stCoRoutineEnv_t 结构的，因此任意协程的 co-&gt;env 指向的结构都相同。切换协程(switch) 上面的启动协程和挂起协程都设计协程的切换，本质是上下文的切换，发生在co_swap()中。 如果是独享栈模式：将当前协程的上下文存好，读取下一协程的上下文。 如果是共享栈模式：libco对共享栈做了个优化，可以申请多个共享栈循环使用，当目标协程所记录的共享栈没有被其它协程占用的时候，整个切换过程和独享栈模式一致。否则就是：将协程的栈空间内容从共享栈拷贝到自己的save_buffer中，将下一协程的save_buffer中的栈内容拷贝到共享栈中，将当前协程的上下文存好，读取下一协程上下文。 协程的本质是，使用ContextSwap，来代替汇编中函数call调用，在保存寄存器上下文后，把需要执行的协程入口push到栈上。void co_swap(stCoRoutine_t* curr, stCoRoutine_t* pending_co){ stCoRoutineEnv_t* env = co_get_curr_thread_env(); //get curr stack sp // 略}这里起寄存器拷贝切换作用的coctx_swap函数，是用汇编来实现的。 coctx_swap接受两个参数，第一个是当前协程的coctx_t指针，第二个参数是待切入的协程的coctx_t指针。该函数调用前还处于第一个协程的环境，调用之后就变成另一个协程的环境了。extern \"C\"{ extern void coctx_swap( coctx_t *,coctx_t* ) asm(\"coctx_swap\");};coctx_swap不再介绍协程的事件管理https://segmentfault.com/a/1190000012834756https://segmentfault.com/a/1190000012656741hook系统libco库通过仅有的几个函数接口 co_create/co_resume/co_yield 再配合 co_poll，可以支持同步或者异步的写法，如线程库一样轻松。同时库里面提供了socket族函数的hook，使得后台逻辑服务几乎不用修改逻辑代码就可以完成异步化改造。静态链接在linux系统中，使用以下命令将源代码编译成可执行文件，源代码经过 预处理，编译，汇编，链接的过程最终生成可执行文件。一个简单的编译命令如下：gcc -o hello hello.c main.c -lcolib使用静态库有许多的缺点： 可执行文件大小过大，造成硬盘的浪费 如果库文件有更新，则依赖该库文件的可执行文件必须重新编译后，才能应用该更新 假设有多个可执行文件都依赖于该库文件，那么每个可执行文件的.code段都会包含相同的机器码，造成内存的浪费动态链接为了解决静态链接的缺点，就出现了动态链接的概念。动态库这个大家都不会陌生，比如Windows的dll文件，Linux的so文件。动态库加载后在系统中只会存有一份，所有依赖它的可执行文件都会共享动态库的code段，data段私有。动态链接的命令如下：gcc -o main main.o -L${libcolib.so path} -lcolib运行时的动态链接系统为我们提供了dlsym、dlopen等函数，用于运行时加载动态库。可执行文件在运行时可以加载不同的动态库，这就为hook系统函数提供了基础。https://man7.org/linux/man-pages/man3/dlsym.3.htmldlopen以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程，dlsym通过句柄和连接符名称获取函数名或者变量名。具体做法在这里就不介绍了。参考资料https://juejin.cn/post/6961414532715511839https://github.com/chenyahui/AnnotatedCode/blob/master/coroutine/coroutine.chttps://www.changliu.me/post/libco-coroutine/https://zhuanlan.zhihu.com/p/94018082https://www.cyhone.com/articles/analysis-of-libco/https://segmentfault.com/a/1190000012834756https://runzhiwang.github.io/2019/06/21/libco/https://www.zhihu.com/question/52193579https://github.com/Tencent/libco/issues/90" }, { "title": "JAVA-Socket通信 聊天室（客户端）", "url": "/posts/client/", "categories": "课设", "tags": "Java", "date": "2022-06-15 13:02:00 +0000", "snippet": "关于聊天室中客户端部分整体思路客户端的代码用到的类如上所示，其中 entity 中的两个类仅用于界面，所以不会进行介绍。Thread客户端线程，一个线程表示一个用户，处理服务器发来的消息，在里面用了 currentFrame 这个变量来表示当前窗口。//客户端线程 监听服务器发送过来的信息public class Thread extends Thread { //当前窗体 private JFrame currentFrame; public ClientThread(JFrame frame){ currentFrame = frame; } public void run() { try { //客户端与服务器处于连接状态 while (DataBuffer.clientSeocket.isConnected()) { //从客户端得输入流读取服务器响应信息 Response response = (Response) DataBuffer.ois.readObject(); ResponseType type = response.getType(); System.out.println(\"获取了响应内容：\" + type); if (type == ResponseType.LOGIN) {//用户登录 User newUser = (User)response.getData(\"loginUser\"); //添加到在线用户列表 DataBuffer.onlineUserListModel.addElement(newUser); //在服务器端重新打印在线用户信息 ChatFrame.onlineCountLbl.setText( \"在线用户列表(\"+ DataBuffer.onlineUserListModel.getSize() +\")\"); ClientUtil.appendTxt2MsgListArea(\"【系统消息】用户\"+newUser.getNickname() + \"上线了！\\n\"); //在客户端页面提示用户上线信息 }else if(type == ResponseType.LOGOUT){ //用户退出 User newUser = (User)response.getData(\"logoutUser\"); //从在线用户列表删除 DataBuffer.onlineUserListModel.removeElement(newUser); //在服务器端重新打印在线用户信息 ChatFrame.onlineCountLbl.setText( \"在线用户列表(\"+ DataBuffer.onlineUserListModel.getSize() +\")\"); ClientUtil.appendTxt2MsgListArea(\"【系统消息】用户\"+newUser.getNickname() + \"下线了！\\n\"); //在客户端聊天界面提示用户下线 }else if(type == ResponseType.CHAT){ //聊天 Message msg = (Message)response.getData(\"txtMsg\"); ClientUtil.appendTxt2MsgListArea(msg.getMessage()); }else if(type == ResponseType.TOSENDFILE){ //准备发送文件 toSendFile(response); }else if(type == ResponseType.AGREERECEIVEFILE){ //对方同意接收文件 sendFile(response); }else if(type == ResponseType.REFUSERECEIVEFILE){ //对方拒绝接收文件 ClientUtil.appendTxt2MsgListArea(\"【文件消息】对方拒绝接收，文件发送失败！\\n\"); }else if(type == ResponseType.RECEIVEFILE){ //开始接收文件 receiveFile(response); }else if(type == ResponseType.BOARD){ //服务器发送广播消息 Message msg = (Message)response.getData(\"txtMsg\"); ClientUtil.appendTxt2MsgListArea(msg.getMessage()); }else if(type == ResponseType.REMOVE){ //服务器剔除用户 ChatFrame.remove(); } } } catch (IOException e) { //e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //发送文件 private void sendFile(Response response) { //创建待发送文件对象 final FileInfo sendFile = (FileInfo)response.getData(\"sendFile\"); //输入输出缓冲字节流 BufferedInputStream bis = null; BufferedOutputStream bos = null; Socket socket = null; try { //套接字连接 socket = new Socket(sendFile.getDestIp(),sendFile.getDestPort()); //文件读入 bis = new BufferedInputStream(new FileInputStream(sendFile.getSrcName())); //文件写出 bos = new BufferedOutputStream(socket.getOutputStream()); //写入缓冲区 byte[] buffer = new byte[1024]; int n = -1; while ((n = bis.read(buffer)) != -1){ bos.write(buffer, 0, n); } bos.flush(); synchronized (this) { //提示消息 ClientUtil.appendTxt2MsgListArea(\"【文件消息】文件发送完毕!\\n\"); } } catch (IOException e) { e.printStackTrace(); }finally{ IOUtil.close(bis,bos); SocketUtil.close(socket); } } //接收文件 private void receiveFile(Response response) { //创建待发送文件对象 final FileInfo sendFile = (FileInfo)response.getData(\"sendFile\"); //输入输出缓冲字节流 BufferedInputStream bis = null; BufferedOutputStream bos = null; ServerSocket serverSocket = null; Socket socket = null; try { serverSocket = new ServerSocket(sendFile.getDestPort()); //接收 socket = serverSocket.accept(); //缓冲读 bis = new BufferedInputStream(socket.getInputStream()); //缓冲写出 bos = new BufferedOutputStream(new FileOutputStream(sendFile.getDestName())); byte[] buffer = new byte[1024]; int n = -1; while ((n = bis.read(buffer)) != -1){ bos.write(buffer, 0, n); } bos.flush(); synchronized (this) { //提示信息 ClientUtil.appendTxt2MsgListArea(\"【文件消息】文件接收完毕!存放在[\" + sendFile.getDestName()+\"]\\n\"); } } catch (IOException e) { e.printStackTrace(); }finally{ IOUtil.close(bis,bos); SocketUtil.close(socket); SocketUtil.close(serverSocket); } } // 准备发送文件 private void toSendFile(Response response) { FileInfo sendFile = (FileInfo)response.getData(\"sendFile\"); //获取发送者昵称 String fromName = sendFile.getFromUser().getNickname() + \"(\" + sendFile.getFromUser().getId() + \")\"; //获取文件名称 String fileName = sendFile.getSrcName() .substring(sendFile.getSrcName().lastIndexOf(File.separator)+1); //弹出提示窗口 获得用户的选择 int select = JOptionPane.showConfirmDialog(this.currentFrame, fromName + \" 向您发送文件 [\" + fileName+ \"]!\\n同意接收吗?\", \"接收文件\", JOptionPane.YES_NO_OPTION); try { Request request = new Request(); request.setAttribute(\"sendFile\", sendFile); //用户同意接受文件 if (select == JOptionPane.YES_OPTION) { //选择接收文件的存放地址 JFileChooser jfc = new JFileChooser(); jfc.setSelectedFile(new File(fileName)); //地址选择结果 int result = jfc.showSaveDialog(this.currentFrame); //地址没有问题 if (result == JFileChooser.APPROVE_OPTION){ //设置目的地文件名 sendFile.setDestName(jfc.getSelectedFile().getCanonicalPath()); //设置目标地的IP和接收文件的端口 sendFile.setDestIp(DataBuffer.ip); sendFile.setDestPort(DataBuffer.RECEIVE_FILE_PORT); request.setAction(\"agreeReceiveFile\"); ClientUtil.appendTxt2MsgListArea(\"【文件消息】您已同意接收来自 \" + fromName +\" 的文件，正在接收文件 ...\\n\"); } else {//地址选择有误或未选择地址 request.setAction(\"refuseReceiveFile\"); ClientUtil.appendTxt2MsgListArea(\"【文件消息】您已拒绝接收来自 \" + fromName +\" 的文件!\\n\"); } } else {//拒绝接受文件 request.setAction(\"refuseReceiveFile\"); ClientUtil.appendTxt2MsgListArea(\"【文件消息】您已拒绝接收来自 \" + fromName +\" 的文件!\\n\"); } ClientUtil.sendTextRequest2(request); } catch (IOException e) { e.printStackTrace(); } }}ClientUtil用于客户端向服务器发送消息。//客户端发送请求到服务器的工具public class ClientUtil { //发送请求对象,主动接收响应 public static Response sendTextRequest(Request request) throws IOException { Response response = null; try { //发送请求 DataBuffer.oos.writeObject(request); DataBuffer.oos.flush(); System.out.println(\"客户端发送了请求对象:\" + request.getAction()); if (!\"exit\".equals(request.getAction())) { // 获取响应 response = (Response) DataBuffer.ois.readObject(); System.out.println(\"客户端获取到了响应对象:\" + response.getStatus()); } else { System.out.println(\"客户端断开连接\"); } } catch (IOException e) { throw e; } catch (ClassNotFoundException e) { e.printStackTrace(); } return response; } //发送请求对象,不主动接收响应 public static void sendTextRequest2(Request request) throws IOException { try { DataBuffer.oos.writeObject(request); // 发送请求 DataBuffer.oos.flush(); System.out.println(\"客户端发送了请求对象:\" + request.getAction()); } catch (IOException e) { throw e; } } //把指定文本添加到消息列表文本域中 public static void appendTxt2MsgListArea(String txt) { ChatFrame.msgListArea.append(txt); //把光标定位到文本域的最后一行 ChatFrame.msgListArea.setCaretPosition(ChatFrame.msgListArea.getDocument().getLength()); }}DataBuffer用于客户端从文件中读取数据，进行缓存。public class DataBuffer { //当前客户端的用户信息 public static User currentUser; //在线用户列表 public static List&lt;User&gt; onlineUsers; //当前客户端连接到服务器的socket public static Socket clientSeocket; //当前客户端连接到服务器的输出流 public static ObjectOutputStream oos; //当前客户端连接到服务器的输入流 public static ObjectInputStream ois; //服务器配置参数属性集 public static Properties configProp; // 当前客户端的屏幕尺寸 public static Dimension screenSize; //本客户端的IP地址 public static String ip ; //用来接收文件的端口 public static final int RECEIVE_FILE_PORT = 6667; // 在线用户JList的Model public static OnlineUserListModel onlineUserListModel; static{ screenSize = Toolkit.getDefaultToolkit().getScreenSize(); //加载服务器配置文件 configProp = new Properties(); try { //获取本地IP地址 ip = InetAddress.getLocalHost().getHostAddress(); //从输入流中读取属性列表（键和元素对） configProp.load(Thread.currentThread() .getContextClassLoader() .getResourceAsStream(\"serverconfig.properties\")); } catch (IOException e) { e.printStackTrace(); } } private DataBuffer(){}}ChatGUI聊天界面大致形状public class ChatGUI extends JFrame { private static final long serialVersionUID = -3426717670093483287L; //聊天对方的信息Label private JLabel otherInfoLbl; //当前用户信息Lbl private JLabel currentUserLbl; //聊天信息列表区域 public static JTextArea msgListArea; //要发送的信息区域 public static JTextArea sendArea; //在线用户列表 public static JList onlineList; // 在线用户数统计Lbl public static JLabel onlineCountLbl; //准备发送文件 public static FileInfo sendFile; //私聊复选框 public JCheckBox rybqBtn; public ChatFrame(){ this.init(); //调用任意已注册 WindowListener 的对象后自动隐藏并释放该窗体。 this.setDefaultCloseOperation(DISPOSE_ON_CLOSE); this.setVisible(true); } //初始化 public void init(){ this.setTitle(\"MY CHART ROOM\"); this.setSize(550, 500); this.setResizable(false); //设置默认窗体在屏幕中央 int x = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth(); int y = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight(); this.setLocation((x - this.getWidth()) / 2, (y-this.getHeight())/ 2); //左边用户面板 JPanel userPanel = new JPanel(); userPanel.setLayout(new BorderLayout()); //右边主面板 JPanel mainPanel = new JPanel(); mainPanel.setLayout(new BorderLayout()); // 创建一个分隔窗格 JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, userPanel, mainPanel); splitPane.setDividerLocation(125); splitPane.setDividerSize(10); splitPane.setOneTouchExpandable(true); this.add(splitPane, BorderLayout.CENTER); //在线用户列表展示 JPanel onlineListPane = new JPanel(); onlineListPane.setLayout(new BorderLayout()); onlineCountLbl = new JLabel(\"在线用户\"); onlineListPane.add(onlineCountLbl, BorderLayout.NORTH); //当前用户面板 JPanel currentUserPane = new JPanel(); currentUserPane.setLayout(new BorderLayout()); Border border = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED); currentUserPane.setBorder(BorderFactory.createTitledBorder(border, \"当前用户\", TitledBorder.LEFT,TitledBorder.TOP)); this.add(currentUserPane, BorderLayout.NORTH); // 右边用户列表创建一个分隔窗格 JSplitPane splitPane3 = new JSplitPane(JSplitPane.VERTICAL_SPLIT, currentUserPane, onlineListPane); splitPane3.setDividerLocation(60); splitPane3.setDividerSize(1); userPanel.add(splitPane3, BorderLayout.CENTER); //获取在线用户并缓存 DataBuffer.onlineUserListModel = new OnlineUserListModel(DataBuffer.onlineUsers); //在线用户列表 onlineList = new JList(DataBuffer.onlineUserListModel); onlineList.setCellRenderer(new MyCellRenderer()); //设置为单选模式 onlineList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); onlineListPane.add(new JScrollPane(onlineList, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER)); //当前用户信息Label currentUserLbl = new JLabel(); currentUserPane.add(currentUserLbl); //右上方信息显示面板 JPanel infoPanel = new JPanel(); infoPanel.setLayout(new BorderLayout()); //右下方发送消息面板 JPanel sendPanel = new JPanel(); sendPanel.setLayout(new BorderLayout()); // 创建一个分隔窗格 JSplitPane splitPane2 = new JSplitPane(JSplitPane.VERTICAL_SPLIT, infoPanel, sendPanel); splitPane2.setDividerLocation(300); splitPane2.setDividerSize(1); mainPanel.add(splitPane2, BorderLayout.CENTER); otherInfoLbl = new JLabel(\"当前状态：群聊中...\"); infoPanel.add(otherInfoLbl, BorderLayout.NORTH); msgListArea = new JTextArea(); msgListArea.setLineWrap(true); //给信息窗口添加滚动条 infoPanel.add(new JScrollPane(msgListArea, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER)); JPanel tempPanel = new JPanel(); tempPanel.setLayout(new BorderLayout()); sendPanel.add(tempPanel, BorderLayout.NORTH); // 聊天按钮面板 JPanel btnPanel = new JPanel(); btnPanel.setLayout(new FlowLayout(FlowLayout.LEFT)); tempPanel.add(btnPanel, BorderLayout.CENTER); //字体按钮 JButton fontBtn = new JButton(new ImageIcon(\"images/font.png\")); fontBtn.setMargin(new Insets(0,0,0,0)); fontBtn.setToolTipText(\"设置字体和格式\"); btnPanel.add(fontBtn); //表情按钮 JButton faceBtn = new JButton(new ImageIcon(\"images/sendFace.png\")); faceBtn.setMargin(new Insets(0,0,0,0)); faceBtn.setToolTipText(\"选择表情\"); btnPanel.add(faceBtn); //发送文件按钮 JButton sendFileBtn = new JButton(new ImageIcon(\"images/sendPic.png\")); sendFileBtn.setMargin(new Insets(0,0,0,0)); sendFileBtn.setToolTipText(\"向对方发送文件\"); btnPanel.add(sendFileBtn); //私聊按钮 rybqBtn = new JCheckBox(\"私聊\"); tempPanel.add(rybqBtn, BorderLayout.EAST); //要发送的信息的区域 sendArea = new JTextArea(); sendArea.setLineWrap(true); sendPanel.add(new JScrollPane(sendArea, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER)); // 聊天按钮面板 JPanel btn2Panel = new JPanel(); btn2Panel.setLayout(new FlowLayout(FlowLayout.RIGHT)); this.add(btn2Panel, BorderLayout.SOUTH); JButton closeBtn = new JButton(\"关闭\"); closeBtn.setToolTipText(\"退出程序\"); btn2Panel.add(closeBtn); JButton submitBtn = new JButton(\"发送\"); submitBtn.setToolTipText(\"按Enter键发送消息\"); btn2Panel.add(submitBtn); sendPanel.add(btn2Panel, BorderLayout.SOUTH); /*-------注册事件监听器--------*/ //关闭窗口 this.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e) { logout(); } }); //关闭按钮的事件 closeBtn.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent event) { logout(); } }); //选择某个用户私聊 rybqBtn.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e) { if(rybqBtn.isSelected()){ User selectedUser = (User)onlineList.getSelectedValue(); if(null == selectedUser){ otherInfoLbl.setText(\"当前状态：私聊(从在线用户列表中选择某个用户进行私聊)...\"); }else if(DataBuffer.currentUser.getId() == selectedUser.getId()){ otherInfoLbl.setText(\"警告：不允许和自己私聊！！！\"); }else{ otherInfoLbl.setText(\"当前状态：与 \"+ selectedUser.getNickname() +\"(\" + selectedUser.getId() + \") 私聊中...\"); } }else{ otherInfoLbl.setText(\"当前状态：群聊...\"); } } }); //选择某个用户 onlineList.addMouseListener(new MouseAdapter() { public void mouseClicked(MouseEvent e) { User selectedUser = (User)onlineList.getSelectedValue(); if(rybqBtn.isSelected()){ if(DataBuffer.currentUser.getId() == selectedUser.getId()){ otherInfoLbl.setText(\"警告：不允许和自己私聊！！！\"); }else{ otherInfoLbl.setText(\"当前状态：与 \"+ selectedUser.getNickname() +\"(\" + selectedUser.getId() + \") 私聊中...\"); } } } }); //发送文本消息 //回车发送 sendArea.addKeyListener(new KeyAdapter(){ public void keyPressed(KeyEvent e){ if(e.getKeyCode() == KeyEvent.VK_ENTER){ sendTxtMsg(); } } }); //点击按钮发送 submitBtn.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent event) { sendTxtMsg(); } }); //发送文件 sendFileBtn.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent event) { sendFile(); } }); this.loadData(); //加载初始数据 } //加载数据 public void loadData(){ //加载当前用户数据 if(null != DataBuffer.currentUser){ //头像 currentUserLbl.setIcon( new ImageIcon(\"images/\" + DataBuffer.currentUser.getHead() + \".png\")); //用户昵称和账号 currentUserLbl.setText(DataBuffer.currentUser.getNickname() + \"(\" + DataBuffer.currentUser.getId() + \")\"); } //设置在线用户列表 onlineCountLbl.setText(\"在线用户列表(\"+ DataBuffer.onlineUserListModel.getSize() +\")\"); //启动监听服务器消息的线程 new ClientThread(this).start(); } //关闭客户端 private void logout() { //弹出提示窗口 int select = JOptionPane.showConfirmDialog(ChatFrame.this, \"确定要退出吗？\\n\\n退出程序将会中断与服务器的连接!\", \"退出聊天室\", JOptionPane.YES_NO_OPTION); //选择退出 if (select == JOptionPane.YES_OPTION) { //创建请求对象 Request req = new Request(); req.setAction(\"exit\"); req.setAttribute(\"user\", DataBuffer.currentUser); try { //发送请求 ClientUtil.sendTextRequest(req); } catch (IOException ex) { ex.printStackTrace(); }finally{ System.exit(0); } }else{ // 未选择退出 不响应 this.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE); } } //服务器踢除用户 public static void remove() { int select = JOptionPane.showConfirmDialog(sendArea, \"你已被踢出聊天室！\\n\\n\", \"系统通知\", JOptionPane.YES_NO_OPTION); //创建请求对象 等同于用户退出 Request req = new Request(); req.setAction(\"exit\"); req.setAttribute(\"user\", DataBuffer.currentUser); try { ClientUtil.sendTextRequest(req); } catch (IOException ex) { ex.printStackTrace(); } finally { System.exit(0); } } //发送文本消息 public void sendTxtMsg(){ String content = sendArea.getText(); if (\"\".equals(content)) { //无内容 JOptionPane.showMessageDialog(ChatFrame.this, \"不能发送空消息!\", \"不能发送\", JOptionPane.ERROR_MESSAGE); } else { //发送 User selectedUser = (User)onlineList.getSelectedValue(); //如果设置了ToUser 表示私聊，否则群聊 Message msg = new Message(); if(rybqBtn.isSelected()){ //私聊 if(null == selectedUser){//私聊对象为空 JOptionPane.showMessageDialog(ChatFrame.this, \"没有选择私聊对象!\", \"不能发送\", JOptionPane.ERROR_MESSAGE); return; }else if (DataBuffer.currentUser.getId() == selectedUser.getId()){//私聊对象为自己 JOptionPane.showMessageDialog(ChatFrame.this, \"不能给自己发送消息!\", \"不能发送\", JOptionPane.ERROR_MESSAGE); return; }else{ msg.setToUser(selectedUser); } } //获取系统时间 msg.setFromUser(DataBuffer.currentUser); msg.setSendTime(new Date()); DateFormat df = new SimpleDateFormat(\"HH:mm:ss\"); //存储消息的相关信息 StringBuffer sb = new StringBuffer(); sb.append(\" \").append(df.format(msg.getSendTime())).append(\" \") .append(msg.getFromUser().getNickname()) .append(\"(\").append(msg.getFromUser().getId()).append(\") \"); if(!this.rybqBtn.isSelected()){ //群聊 sb.append(\"对大家说\"); } sb.append(\"\\n \").append(content).append(\"\\n\"); msg.setMessage(sb.toString()); //创建请求对象 存储消息信息 Request request = new Request(); request.setAction(\"chat\"); request.setAttribute(\"msg\", msg); try { //发送请求 ClientUtil.sendTextRequest2(request); } catch (IOException e) { e.printStackTrace(); } //JTextArea 中发送消息后，清空内容并回到首行 InputMap inputMap = sendArea.getInputMap(); ActionMap actionMap = sendArea.getActionMap(); Object transferTextActionKey = \"TRANSFER_TEXT\"; inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),transferTextActionKey); actionMap.put(transferTextActionKey,new AbstractAction() { private static final long serialVersionUID = 7041841945830590229L; public void actionPerformed(ActionEvent e) { sendArea.setText(\"\"); sendArea.requestFocus(); } }); sendArea.setText(\"\"); ClientUtil.appendTxt2MsgListArea(msg.getMessage()); } } //发送文件 private void sendFile() { User selectedUser = (User)onlineList.getSelectedValue(); if(null != selectedUser){ //选择了发送文件的对象 if(DataBuffer.currentUser.getId() == selectedUser.getId()){ JOptionPane.showMessageDialog(ChatFrame.this, \"不能给自己发送文件!\", \"不能发送\", JOptionPane.ERROR_MESSAGE); }else{ //选择要发送的文件 JFileChooser jfc = new JFileChooser(); if (jfc.showOpenDialog(ChatFrame.this) == JFileChooser.APPROVE_OPTION) { File file = jfc.getSelectedFile(); //创建要发送的文件对象 存储文件内容及相关信息 sendFile = new FileInfo(); //设置文件发送者 sendFile.setFromUser(DataBuffer.currentUser); //设置文件接收者 sendFile.setToUser(selectedUser); try { //待发送文件的源地址及文件名 sendFile.setSrcName(file.getCanonicalPath()); } catch (IOException e1) { e1.printStackTrace(); } //设置发送时间 sendFile.setSendTime(new Date()); //创建请求对象 Request request = new Request(); request.setAction(\"toSendFile\"); request.setAttribute(\"file\", sendFile); try { //发送请求 ClientUtil.sendTextRequest2(request); } catch (IOException e) { e.printStackTrace(); } //打印提示信息 ClientUtil.appendTxt2MsgListArea(\"【文件消息】向 \" + selectedUser.getNickname() + \"(\" + selectedUser.getId() + \") 发送文件 [\" + file.getName() + \"]，等待对方接收...\\n\"); } } }else{ JOptionPane.showMessageDialog(ChatFrame.this, \"警告：只能给指定用户发送文件！！！\", \"不能发送\", JOptionPane.ERROR_MESSAGE); } }}LoginGUI登录界面大致如下public class LoginGUI extends JFrame{ private static final long serialVersionUID = -3426717670093483287L; private JTextField idTxt; private JPasswordField pwdFld; public LoginFrame(){ this.init(); setVisible(true); } public void init(){ this.setTitle(\"登录\"); this.setSize(430,330); //设置默认窗口在屏幕中央 int x = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth(); int y = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight(); this.setLocation((x-this.getWidth())/2,(y-this.getHeight())/2); //不允许用户改变窗口大小； this.setResizable(false); //把logo放在JFrame的上面 Icon icon = new ImageIcon(\"images/logo.png\"); JLabel label = new JLabel(icon); label.setPreferredSize(new Dimension(430,150)); this.add(label,BorderLayout.NORTH); //登录信息 JPanel mainPanel = new JPanel(); // 具有“浮雕化”外观效果的边框(效果为凹陷) Border border = BorderFactory.createEtchedBorder(EtchedBorder.LOWERED); mainPanel.setBorder(BorderFactory.createTitledBorder(border,\"输入登录信息\",TitledBorder.CENTER,TitledBorder.TOP)); this.add(mainPanel,BorderLayout.CENTER); mainPanel.setLayout(null); JLabel nameLbl = new JLabel(\"账号\"); nameLbl.setBounds(110,30,70,22); mainPanel.add(nameLbl); idTxt = new JTextField(); idTxt.setBounds(150,30,150,22); idTxt.requestFocusInWindow();//用户名获得焦点 mainPanel.add(idTxt); JLabel pwdLbl = new JLabel(\"密码\"); pwdLbl.setBounds(110,60,40,22); mainPanel.add(pwdLbl); pwdFld = new JPasswordField(); pwdFld.setBounds(150,60,150,22); mainPanel.add(pwdFld); //按钮面板放置在JFrame的下面 JPanel btnPanel = new JPanel(); this.add(btnPanel,BorderLayout.SOUTH); btnPanel.setLayout(new BorderLayout()); btnPanel.setBorder(new EmptyBorder(2,8,4,8)); JButton registenBtn = new JButton(\"注册\"); btnPanel.add(registenBtn,BorderLayout.WEST); JButton submitBtn = new JButton(\"登录\"); btnPanel.add(submitBtn,BorderLayout.EAST); //关闭窗口 this.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e){ Request req = new Request(); req.setAction(\"exit\"); try{ ClientUtil.sendTextRequest(req); }catch(IOException ex){ ex.printStackTrace(); }finally { System.exit(0); } } }); //注册 registenBtn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { new RegisterFrame(); } }); //登录 submitBtn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { login(); } }); } //登录 private void login(){ if(idTxt.getText().length()==0||pwdFld.getPassword().length==0){ JOptionPane.showMessageDialog(LoginFrame.this, \"请输入账号密码！，\" , \"输入有误\",JOptionPane.ERROR_MESSAGE); idTxt.requestFocusInWindow(); return; } //创建请求 Request req = new Request(); req.setAction(\"userLogin\"); req.setAttribute(\"id\", idTxt.getText()); req.setAttribute(\"password\", new String(pwdFld.getPassword())); //获取响应 Response response = null; try { response = ClientUtil.sendTextRequest(req); } catch (IOException e1) { e1.printStackTrace(); } if(response.getStatus() == ResponseStatus.OK){ //获取当前用户 User user2 = (User)response.getData(\"user\"); if(user2!= null){ //登录成功 DataBuffer.currentUser = user2; //获取当前在线用户列表 DataBuffer.onlineUsers = (List&lt;User&gt;)response.getData(\"onlineUsers\"); LoginFrame.this.dispose(); new ChatFrame(); //打开聊天窗口 }else{ //登录失败 String str = (String)response.getData(\"msg\"); JOptionPane.showMessageDialog(LoginFrame.this, str, \"登录失败\",JOptionPane.ERROR_MESSAGE); } }else{ JOptionPane.showMessageDialog(LoginFrame.this, \"服务器内部错误，请稍后再试！！！\",\"登录失败\",JOptionPane.ERROR_MESSAGE); } }}RegisterGUI注册界面大致如下public class RegisterGUI extends JFrame{ private static final long serialVersionUID = -768631070458723803L; private JPasswordField pwdFld; private JPasswordField pwd2Fld; private JTextField nickname; private JComboBox head; private JRadioButton sex0; private JRadioButton sex1; private JButton ok; private JButton reset; private JButton cancel; public RegisterFrame(){ this.init(); setVisible(true); } public void init(){ this.setTitle(\"注册新账号\"); setBounds((DataBuffer.screenSize.width - 387)/2, (DataBuffer.screenSize.height - 267)/2, 387, 267); getContentPane().setLayout(null); setResizable(false); JLabel lable =new JLabel(\"昵称\");//label显示 lable.setBounds(24,35,59,17); getContentPane().add(lable); nickname = new JTextField(); //昵称 nickname.setBounds(90, 34, 110, 22); getContentPane().add(nickname); JLabel label5 = new JLabel(\"密码: *\"); label5.setBounds(24, 72, 50, 17); getContentPane().add(label5); JLabel label3 = new JLabel(\"确认密码: *\"); label3.setBounds(24, 107, 65, 17); getContentPane().add(label3); pwdFld = new JPasswordField(); //密码框 pwdFld.setBounds(90, 70, 110, 22); getContentPane().add(pwdFld); pwd2Fld = new JPasswordField(); //确认密码框 pwd2Fld.setBounds(90, 105, 110, 22); getContentPane().add(pwd2Fld); JLabel label4 = new JLabel(\"性别:\"); label4.setBounds(230, 36, 31, 17); getContentPane().add(label4); sex1 = new JRadioButton(\"女\",true); //性别选项 sex1.setBounds (268, 31,44, 25); getContentPane().add(sex1); sex0 = new JRadioButton(\"男\"); sex0.setBounds(310, 31, 44, 25); getContentPane().add(sex0); ButtonGroup buttonGroup = new ButtonGroup(); //单选按钮组 buttonGroup.add(sex0); buttonGroup.add(sex1); JLabel label6 = new JLabel(\"头像:\"); label6.setBounds(230, 72, 31, 17); getContentPane().add(label6); head = new JComboBox(); //下拉列表图标 head.setBounds(278, 70, 65, 45); head.setMaximumRowCount(5); for (int i = 0; i &lt; 13; i++) { head.addItem(new ImageIcon(\"images/\" + i + \".png\")); //通过循环添加图片 注意图片名字要取成1,2,3,4,5,等 } head.setSelectedIndex(0); getContentPane().add(head); //按钮 ok = new JButton(\"确认\"); ok.setBounds(27, 176, 60, 28); getContentPane().add(ok); reset = new JButton(\"重填\"); reset.setBounds(123, 176, 60, 28); getContentPane().add(reset); cancel = new JButton(\"取消\"); cancel.setBounds(268, 176, 60, 28); getContentPane().add(cancel); /*---------注册事件监听器----------*/ //取消按钮监听事件处理 cancel.addActionListener(new ActionListener() { @Override public void actionPerformed(final ActionEvent event) { RegisterFrame.this.dispose(); } }); //关闭窗口 this.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e){ RegisterFrame.this.dispose(); } }); // 重置按钮监听事件处理 reset.addActionListener(new ActionListener() { public void actionPerformed(final ActionEvent e) { nickname.setText(\"\"); pwdFld.setText(\"\"); pwd2Fld.setText(\"\"); nickname.requestFocusInWindow(); //用户名获得焦点 } }); //确认按钮监听事件处理 ok.addActionListener(new ActionListener() { public void actionPerformed(final ActionEvent e) { if (pwdFld.getPassword().length==0 || pwd2Fld.getPassword().length==0) { JOptionPane.showMessageDialog(RegisterFrame.this, \"带 “ * ” 为必填内容!\"); //判断用户名和密码是否为空 } else if (!new String(pwdFld.getPassword()).equals(new String(pwd2Fld.getPassword()))) { JOptionPane.showMessageDialog(RegisterFrame.this, \"两次输入密码不一致!\"); pwdFld.setText(\"\"); pwd2Fld.setText(\"\"); pwdFld.requestFocusInWindow(); //判断两次密码是否一致 } else { User user = new User(new String(pwdFld.getPassword()), nickname.getText(), sex0.isSelected() ? 'm' : 'f', head.getSelectedIndex()); try { RegisterFrame.this.regist(user); } catch (IOException e1) { e1.printStackTrace(); } catch (ClassNotFoundException ex) { ex.printStackTrace(); } } } }); } //注册 private void regist(User user) throws IOException, ClassNotFoundException{ Request request = new Request(); request.setAction(\"userRegist\"); request.setAttribute(\"user\",user); //获得响应 Response response = ClientUtil.sendTextRequest(request); ResponseStatus status=response.getStatus(); switch (status){ case OK: User user2 = (User)response.getData(\"user\"); JOptionPane.showMessageDialog(RegisterFrame.this, \"注册成功，您的账号为 :\"+ user2.getId() + \",请牢记!!!\", \"注册成功\",JOptionPane.INFORMATION_MESSAGE); this.setVisible(false); break; default: JOptionPane.showMessageDialog(RegisterFrame.this, \"注册失败，请稍后再试！！！\", \"服务器内部错误！\", JOptionPane.ERROR_MESSAGE); } }}运行结果基本完成，除了不够美观。个人认为项目的难点是在客户端，之前考虑了很久关于界面的切换，因为涉及到了登陆界面、注册界面、聊天界面，所以如何将客户端的socket与这几个界面联系起来是个值得思考的问题。同时，也思考了好久好友列表的展示方法，最后参考了别人的设计方法。" }, { "title": "JAVA-Socket通信 聊天室（服务端）", "url": "/posts/Service/", "categories": "课设", "tags": "Java", "date": "2022-06-15 13:02:00 +0000", "snippet": "关于聊天室中服务器部分一个聊天室，我们可以将其分为服务端和客户端，而通信的简易过程如下图所示对于服务器，我们需要做的是1、验证用户登陆信息。2、接收用户发送的信息并转发给目标用户整体思路Server端UserService用于用户账号管理，预先创建几个账号，然后存到文件中，每次服务器执行时，都会将文件中的账号信息读入，同时新创建的用户账号也会存入到文件中去。public class UserService { private static int idCount =3;//id //新增用户 public void addUser(User user){ user.setId(++idCount); List&lt;User&gt; users = loadAllUser(); users.add(user); saveAllUser(users); } //用户登录 public User login(long id,String password){ User result = null; List&lt;User&gt; users =loadAllUser(); for(User user : users){ if(id == user.getId()&amp;&amp;password.equals(user.getPassword())){ result=user; break; } } return result; } //根据ID加载用户 public User loadUser(long id){ User result = null; List&lt;User&gt; users=loadAllUser(); for(User user:users){ if(id==user.getId()){ result=user; break; } } return result; } //加载所有用户 public List&lt;User&gt; loadAllUser(){ List&lt;User&gt; list = null; ObjectInputStream ois =null; try { ois = new ObjectInputStream( new FileInputStream( DataBuffer.configProp.getProperty(\"dbpath\"))); list =(List&lt;User&gt;) ois.readObject(); }catch (Exception e){ e.printStackTrace(); }finally { IOUtil.close(ois); } return list; } //保存所有用户 private void saveAllUser(List&lt;User&gt; users){ ObjectOutputStream oos =null; try{ oos = new ObjectOutputStream( new FileOutputStream( DataBuffer.configProp.getProperty(\"dbpath\"))); //写回用户信息 oos.writeObject(users); oos.flush(); }catch (Exception e){ e.printStackTrace(); }finally { IOUtil.close(oos); } } //初始化几个测试用户 public void initUser(){ User user = new User(\"admin\", \"Admin\", 'm', 0); user.setId(1); User user2 = new User(\"123456\", \"Tom\", 'm', 1); user2.setId(2); User user3 = new User(\"123456\", \"Lily\", 'f', 2); user3.setId(3); List&lt;User&gt; users = new CopyOnWriteArrayList&lt;User&gt;(); users.add(user); users.add(user2); users.add(user3); this.saveAllUser(users); } public static void main(String[] args){ new UserService().initUser(); List&lt;User&gt; users = new UserService().loadAllUser(); for (User user : users) { System.out.println(user); } }}DataBuffer用于服务器端从文件中读取数据，进行缓存public class DataBuffer { // 服务器端socket public static ServerSocket serverSocket; //在线用户的IO Map public static Map&lt;Long,OnlineClientIOCache&gt; onlineUserIOCacheMap; //在线用户Map public static Map&lt;Long,User&gt; onlineUsersMap; //服务器配置参数属性集 public static Properties configProp; //已注册用户表的Model public static RegistedUserTableModel registedUserTableModel; // 当前在线用户表的Model public static OnlineUserTableModel onlineUserTableModel; // 当前服务器所在系统的屏幕尺寸 public static Dimension screenSize; // 当前用户数据库 public static UserService userService; static{ // 初始化 //ConcurrentSkipListMap: 线程安全的有序的哈希表 适用于高并发的场景 onlineUserIOCacheMap = new ConcurrentSkipListMap&lt;Long, OnlineClientIOCache&gt;(); //在线用户的IO缓存map onlineUsersMap = new ConcurrentSkipListMap&lt;Long, User&gt;(); //在线用户map configProp = new Properties(); //创建配置文件 registedUserTableModel = new RegistedUserTableModel(); //初始化几个已注册用户 onlineUserTableModel = new OnlineUserTableModel(); //获取在线用户 screenSize = Toolkit.getDefaultToolkit().getScreenSize(); //获取屏幕尺寸 userService = new UserService(); //创建服务器 // 加载服务器配置文件 try { configProp.load(Thread.currentThread() .getContextClassLoader() .getResourceAsStream(\"serverconfig.properties\")); } catch (IOException e) { e.printStackTrace(); } }}RequestProcessor这时服务器端最重要的一个类了，用于处理客户端发来的消息，并进行回复，对于每一项操作的实现原理无非就是服务器处理内部数据或是向指定客户端发送消息，详细看代码注释//针对每个用户的服务线程public class RequestProcessor implements Runnable { //当前正在请求服务器的客户端Socket private Socket currentClientSocket; public RequestProcessor(Socket currentClientSocket){ this.currentClientSocket=currentClientSocket; } public void run(){ boolean flag = true;//是否不断监听 try{ OnlineClientIOCache currentClientIOCache = new OnlineClientIOCache( new ObjectInputStream(currentClientSocket.getInputStream()), new ObjectOutputStream(currentClientSocket.getOutputStream())); while (flag){ //不停地读取客户端发过来的请求对象 //从请求输入流中读取到客户端提交的请求对象 Request request = (Request)currentClientIOCache.getOis().readObject(); System.out.println(\"Server读取了客户端的请求:\" + request.getAction()); //获取请求中的动作 String actionName = request.getAction(); if(actionName.equals(\"userRegist\")){ //用户注册 regist(currentClientIOCache, request); }else if(actionName.equals(\"userLogin\")){ //用户登录 login(currentClientIOCache, request); }else if(\"exit\".equals(actionName)){ //请求断开连接 flag = logout(currentClientIOCache, request); }else if(\"chat\".equals(actionName)){ //聊天 chat(request); }else if(\"toSendFile\".equals(actionName)){ //准备发送文件 toSendFile(request); }else if(\"agreeReceiveFile\".equals(actionName)){ //同意接收文件 agreeReceiveFile(request); }else if(\"refuseReceiveFile\".equals(actionName)){ //拒绝接收文件 refuseReceiveFile(request); } } }catch (Exception e){ e.printStackTrace(); } } //注册 public void regist(OnlineClientIOCache oio,Request request) throws IOException{ User user = (User)request.getAttribute(\"user\"); DataBuffer.userService.addUser(user); //创建一个响应对象 Response response = new Response(); response.setStatus(ResponseStatus.OK); response.setData(\"user\",user); //向客户端写入响应对象 oio.getOos().writeObject(response); oio.getOos().flush(); //把新注册用户添加到RegistedUserTableModel中 DataBuffer.registedUserTableModel.add(new String[]{ String.valueOf(user.getId()), user.getPassword(), user.getNickname(), String.valueOf(user.getSex())}); } //登录 void login(OnlineClientIOCache currentClientIO, Request request) throws IOException { //获取输入的账号密码 String idStr = (String)request.getAttribute(\"id\"); String password = (String) request.getAttribute(\"password\"); //建立服务对象 UserService userService = new UserService(); User user = userService.login(Long.parseLong(idStr), password); Response response = new Response(); //创建一个响应对象 if(null != user){ if(DataBuffer.onlineUsersMap.containsKey(user.getId())){ //用户已经登录了 response.setStatus(ResponseStatus.OK); response.setData(\"msg\", \"该用户已经在别处上线了！\"); currentClientIO.getOos().writeObject(response); //把响应对象往客户端写 currentClientIO.getOos().flush(); }else { //正确登录 DataBuffer.onlineUsersMap.put(user.getId(), user); //添加到在线用户 //设置在线用户 response.setData(\"onlineUsers\", new CopyOnWriteArrayList&lt;User&gt;(DataBuffer.onlineUsersMap.values())); response.setStatus(ResponseStatus.OK); response.setData(\"user\", user); currentClientIO.getOos().writeObject(response); //把响应对象往客户端写 currentClientIO.getOos().flush(); //通知其它用户有人上线了 Response response2 = new Response(); response2.setType(ResponseType.LOGIN); response2.setData(\"loginUser\", user); iteratorResponse(response2); //把当前上线的用户IO添加到缓存Map中 DataBuffer.onlineUserIOCacheMap.put(user.getId(),currentClientIO); //把当前上线用户添加到OnlineUserTableModel中 DataBuffer.onlineUserTableModel.add( new String[]{String.valueOf(user.getId()), user.getNickname(), String.valueOf(user.getSex())}); } }else{ //登录失败 response.setStatus(ResponseStatus.OK); response.setData(\"msg\", \"账号或密码不正确！\"); currentClientIO.getOos().writeObject(response); currentClientIO.getOos().flush(); } } //用户退出 public boolean logout(OnlineClientIOCache oio, Request request) throws IOException{ System.out.println(currentClientSocket.getInetAddress().getHostAddress() + \":\" + currentClientSocket.getPort() + \"走了\"); User user = (User)request.getAttribute(\"user\"); //把当前在线客户端的IO从Map中删除 DataBuffer.onlineUserIOCacheMap.remove(user.getId()); //从在线用户缓存Map中删除当前用户 DataBuffer.onlineUsersMap.remove(user.getId()); Response response = new Response(); //创建一个响应对象 response.setType(ResponseType.LOGOUT); response.setData(\"logoutUser\", user); oio.getOos().writeObject(response); //把响应对象往客户端写 oio.getOos().flush(); currentClientSocket.close(); //关闭这个客户端Socket DataBuffer.onlineUserTableModel.remove(user.getId()); //把当前下线用户从在线用户表Model中删除 iteratorResponse(response); //通知所有其它在线客户端 return false; //断开监听 } //聊天 public void chat(Request request) throws IOException { //获取消息内容 Message msg = (Message)request.getAttribute(\"msg\"); //创建响应对象 Response response = new Response(); response.setStatus(ResponseStatus.OK); response.setType(ResponseType.CHAT); response.setData(\"txtMsg\", msg); if(msg.getToUser() != null){ //私聊:只给私聊的对象返回响应 OnlineClientIOCache io = DataBuffer.onlineUserIOCacheMap.get(msg.getToUser().getId()); sendResponse(io, response); }else{ //群聊:给除了发消息的所有客户端都返回响应 for(Long id : DataBuffer.onlineUserIOCacheMap.keySet()){ if(msg.getFromUser().getId() == id ){ continue; } sendResponse(DataBuffer.onlineUserIOCacheMap.get(id), response); } } } //服务器广播 public static void board(String str) throws IOException { //用户admin做为消息发送者 User user = new User(1,\"admin\"); Message msg = new Message(); msg.setFromUser(user); msg.setSendTime(new Date()); DateFormat df = new SimpleDateFormat(\"HH:mm:ss\"); StringBuffer sb = new StringBuffer(); sb.append(\" \").append(df.format(msg.getSendTime())).append(\" \"); sb.append(\"系统通知\\n \"+str+\"\\n\"); msg.setMessage(sb.toString()); //创建响应对象 Response response = new Response(); response.setStatus(ResponseStatus.OK); response.setType(ResponseType.BOARD); response.setData(\"txtMsg\", msg); //向每个在线用户返回响应 for (Long id : DataBuffer.onlineUserIOCacheMap.keySet()) { sendResponse_sys(DataBuffer.onlineUserIOCacheMap.get(id), response); } } //服务器踢除用户 public static void remove(User user_) throws IOException{ User user = new User(1,\"admin\"); Message msg = new Message(); msg.setFromUser(user); msg.setSendTime(new Date()); msg.setToUser(user_); StringBuffer sb = new StringBuffer(); DateFormat df = new SimpleDateFormat(\"HH:mm:ss\"); sb.append(\" \").append(df.format(msg.getSendTime())).append(\" \"); sb.append(\"系统通知您\\n \"+\"您被强制下线\"+\"\\n\"); msg.setMessage(sb.toString()); Response response = new Response(); response.setStatus(ResponseStatus.OK); response.setType(ResponseType.REMOVE); response.setData(\"txtMsg\", msg); OnlineClientIOCache io = DataBuffer.onlineUserIOCacheMap.get(msg.getToUser().getId()); sendResponse_sys(io, response); } //服务器发送私信 public static void chat_sys(String str,User user_) throws IOException{ User user = new User(1,\"admin\"); Message msg = new Message(); msg.setFromUser(user); msg.setSendTime(new Date()); msg.setToUser(user_); DateFormat df = new SimpleDateFormat(\"HH:mm:ss\"); StringBuffer sb = new StringBuffer(); sb.append(\" \").append(df.format(msg.getSendTime())).append(\" \"); sb.append(\"系统通知您\\n \"+str+\"\\n\"); msg.setMessage(sb.toString()); Response response = new Response(); response.setStatus(ResponseStatus.OK); response.setType(ResponseType.CHAT); response.setData(\"txtMsg\", msg); OnlineClientIOCache io = DataBuffer.onlineUserIOCacheMap.get(msg.getToUser().getId()); sendResponse_sys(io, response); } //拒绝接收文件 private void refuseReceiveFile(Request request) throws IOException { FileInfo sendFile = (FileInfo)request.getAttribute(\"sendFile\"); Response response = new Response(); //创建一个响应对象 response.setType(ResponseType.REFUSERECEIVEFILE); response.setData(\"sendFile\", sendFile); response.setStatus(ResponseStatus.OK); //向请求方的输出流输出响应 OnlineClientIOCache ocic = DataBuffer.onlineUserIOCacheMap.get(sendFile.getFromUser().getId()); this.sendResponse(ocic, response); } //同意接收文件 private void agreeReceiveFile(Request request) throws IOException { FileInfo sendFile = (FileInfo)request.getAttribute(\"sendFile\"); //向请求方(文件发送方)的输出流输出响应 Response response = new Response(); //创建一个响应对象 response.setType(ResponseType.AGREERECEIVEFILE); response.setData(\"sendFile\", sendFile); response.setStatus(ResponseStatus.OK); OnlineClientIOCache sendIO = DataBuffer.onlineUserIOCacheMap.get(sendFile.getFromUser().getId()); this.sendResponse(sendIO, response); //向文件接收方发出接收文件的响应 Response response2 = new Response(); //创建一个响应对象 response2.setType(ResponseType.RECEIVEFILE); response2.setData(\"sendFile\", sendFile); response2.setStatus(ResponseStatus.OK); OnlineClientIOCache receiveIO = DataBuffer.onlineUserIOCacheMap.get(sendFile.getToUser().getId()); this.sendResponse(receiveIO, response2); } // 准备发送文件 public void toSendFile(Request request)throws IOException{ Response response = new Response(); response.setStatus(ResponseStatus.OK); response.setType(ResponseType.TOSENDFILE); FileInfo sendFile = (FileInfo)request.getAttribute(\"file\"); response.setData(\"sendFile\", sendFile); //给文件接收方转发文件发送方的请求 OnlineClientIOCache ioCache = DataBuffer.onlineUserIOCacheMap.get(sendFile.getToUser().getId()); sendResponse(ioCache, response); } //向指定客户端IO的输出流中输出指定响应 private void sendResponse(OnlineClientIOCache onlineUserIO, Response response)throws IOException { ObjectOutputStream oos = onlineUserIO.getOos(); oos.writeObject(response); oos.flush(); } // 向指定客户端IO的输出流中输出指定响应 private static void sendResponse_sys(OnlineClientIOCache onlineUserIO, Response response)throws IOException { ObjectOutputStream oos = onlineUserIO.getOos(); oos.writeObject(response); oos.flush(); } //给所有在线客户都发送响应 private void iteratorResponse(Response response) throws IOException { for(OnlineClientIOCache onlineUserIO : DataBuffer.onlineUserIOCacheMap.values()){ ObjectOutputStream oos = onlineUserIO.getOos(); oos.writeObject(response); oos.flush(); } }}ServerInfoGUI界面大致形状public class ServerInfoFrame extends JFrame{ private static final long serialVersionUID = 6274443611957724780L; //发送信息输入窗口 private JTextField jta_msg; //在线用户表 private JTable onlineUserTable; //已注册用户表 private JTable registedUserTable; public ServerInfoFrame(){ init(); loadData(); setVisible(true); } //初始化窗体 public void init(){ this.setTitle(\"服务器启动\"); this.setBounds((DataBuffer.screenSize.width - 700)/2, (DataBuffer.screenSize.height - 475)/2, 700, 475); this.setLayout(new BorderLayout()); JPanel panel = new JPanel(); Border border=BorderFactory.createEtchedBorder(EtchedBorder.LOWERED); panel.setBorder(BorderFactory.createTitledBorder(border,\"服务器监听中\",TitledBorder.LEFT,TitledBorder.TOP)); this.add(panel,BorderLayout.NORTH); int port = Integer.parseInt(DataBuffer.configProp.getProperty(\"port\")); JLabel label =new JLabel(\"服务器端口：\\n\"+port); panel.add(label); JButton exitBtn = new JButton(\"关闭服务器\"); panel.add(exitBtn); JLabel la_msg =new JLabel(\"要发送的消息\"); panel.add(la_msg); //服务器要发送消息的输入框 jta_msg = new JTextField(30); //定义一个监听器对象：发送广播消息 ActionListener sendCaseMsgAction = new ActionListener() { @Override public void actionPerformed(ActionEvent e) { try{ sendAllMsg(); }catch (IOException e1){ e1.printStackTrace();; } } }; //给输入框加上事件监听器，按回车发送； jta_msg.addActionListener(sendCaseMsgAction); JButton bu_send = new JButton(\"send\"); //给按钮加上发送广播消息的监听器 bu_send.addActionListener(sendCaseMsgAction); panel.add(jta_msg); panel.add(bu_send); //使用服务器缓存中的TableMo onlineUserTable = new JTable(DataBuffer.onlineUserTableModel); registedUserTable = new JTable(DataBuffer.registedUserTableModel); //取得表格上的弹出菜单对象，加到表格上； JPopupMenu pop = getTablePop(); onlineUserTable.setComponentPopupMenu(pop); //选项卡 JTabbedPane tabbedPane = new JTabbedPane(); tabbedPane.addTab(\"在线用户列表\",new JScrollPane(onlineUserTable)); tabbedPane.addTab(\"已注册用户列表\",new JScrollPane(registedUserTable)); tabbedPane.setTabComponentAt(0,new JLabel(\"在线用户列表\")); this.add(tabbedPane,BorderLayout.CENTER); final JLabel stateBar = new JLabel(\"\",SwingConstants.RIGHT); stateBar.setBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED)); //用定时任务来显示当前时间 new java.util.Timer().scheduleAtFixedRate( new TimerTask() { DateFormat df =new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); @Override public void run() { stateBar.setText(\"当前时间：\" + df.format(new Date()) + \" \"); } },0,1000 ); //把状态栏添加到窗体的南边 this.add(stateBar,BorderLayout.SOUTH); //关闭窗口 this.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e) { logout(); } }); /* 添加关闭服务器按钮事件处理方法 */ exitBtn.addActionListener(new ActionListener() { public void actionPerformed(final ActionEvent event) { logout(); } }); } //创建表格上的弹出菜单对象 实现发信 踢人功能 private JPopupMenu getTablePop(){ //弹出菜单对象 JPopupMenu pop =new JPopupMenu(); JMenuItem mi_send = new JMenuItem(\"发信\"); //菜单项对象 //设定菜单命令关键字 mi_send.setActionCommand(\"send\"); //菜单项对象 JMenuItem mi_del = new JMenuItem(\"踢掉\"); //设定菜单命令关键字 mi_del.setActionCommand(\"del\"); //弹出菜单上的监视器对象 ActionListener al =new ActionListener() { @Override public void actionPerformed(ActionEvent e) { // 哪个菜单项点击了 这个s就是其设定的ActionCommand String s= e.getActionCommand(); popMenuAction(s); } }; mi_send.addActionListener(al); mi_del.addActionListener(al); pop.add(mi_send); pop.add(mi_del); return pop; } // 处理弹出菜单上的事件 private void popMenuAction(String command){ // 得到在表格上选中的行 final int selectIndex = onlineUserTable.getSelectedRow(); String usr_id = (String) onlineUserTable.getValueAt(selectIndex,0); System.out.println(usr_id); if(selectIndex==-1){ JOptionPane.showMessageDialog(this,\"请选择一个用户\"); return; } if (command.equals(\"del\")) { // 从线程中移除处理线程对象 try { RequestProcessor.remove(DataBuffer.onlineUsersMap.get(Long.valueOf(usr_id))); } catch (IOException e) { e.printStackTrace(); } } else if(command.equals(\"send\")){ final JDialog jd = new JDialog(this,true); jd.setLayout(new FlowLayout()); jd.setSize(200,100); final JTextField jtd_m = new JTextField(20); JButton jb = new JButton(\"发送\"); jd.add(jtd_m); jd.add(jb); //发送按钮的事件实现 jb.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\"服务器发送了一条消息\"); String msg = jtd_m.getText(); try { RequestProcessor.chat_sys(msg,DataBuffer.onlineUsersMap.get(Long.valueOf(usr_id))); }catch (IOException e1){ e1.printStackTrace(); } //清空输入框 jtd_m.setText(\"\"); jd.dispose(); } }); jd.setVisible(true); }else{ JOptionPane.showMessageDialog(this,\"未知菜单\"+command); } //刷新表格 SwingUtilities.updateComponentTreeUI(onlineUserTable); } //按下发送服务器消息的按钮，给所有在线用户发送消息 private void sendAllMsg() throws IOException{ RequestProcessor.board(jta_msg.getText()); //清空输入框 jta_msg.setText(\"\"); } //把所有已注册的用户信息加载到RegistedUserTableModel中 private void loadData(){ List&lt;User&gt; users=new UserService().loadAllUser(); for(User user:users){ DataBuffer.registedUserTableModel.add(new String[]{ String.valueOf(user.getId()), user.getPassword(), user.getNickname(), String.valueOf(user.getSex()) }); } } //关闭服务器 private void logout(){ //弹出提示窗口 int select = JOptionPane.showConfirmDialog(ServerInfoFrame.this, \"确定关闭吗？\\n\\n关闭服务器将中断与所有客户端的连接!\", \"关闭服务器\", JOptionPane.YES_NO_OPTION); //如果用户点击的是关闭服务器按钮时会提示是否确认关闭。 if (select == JOptionPane.YES_OPTION) { System.exit(0);//退出系统 }else{ //覆盖默认的窗口关闭事件动作 setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE); } }}entity 中的两个类仅用于界面，所以不会进行介绍。运行结果基本完成，看起来还不错，就是有点丑。" }, { "title": "JAVA-Socket通信 聊天室", "url": "/posts/chartroom/", "categories": "课设", "tags": "Java", "date": "2022-06-15 13:02:00 +0000", "snippet": "聊天室曾经盛行一时，今天我们就用简单的java代码来复刻他。一、项目名称聊天室二、功能介绍 用Java图形用户界面编写聊天室服务器端和客户端， 支持多个客户端连接到一个服务器。每个客户端能够输入账号，包括注册功能。 可以实现群聊（聊天记录显示在所有客户端界面）。 完成好友列表在各个客户端上显示，包括头像和用户名。 可以实现私人聊天，用户可以选择某个其他用户，单独发送信息，同时实现了文件传输。 服务器能够群发系统消息，能够对用户私发消息，能够强行让某些用户下线。 客户端的上线下线要求能够在其他客户端上面实时刷新。 服务器能够查看在线用户和注册用户三、模块功能服务器与客户端之间的交互简图服务器与客户端的功能缩略图具体框架Client端Server端工具类四、开发模式：MVC模式M:model(数据层)V：view(显示层)C：controller(控制层)五：以上是大概的框架UML图（大致构思）：总结在网络越来越发达的今天, 人们越来越依赖于网络, 越来越离不开网络, 由此而产生的聊天工具越来越多, 类似QQ、MSN, 网络聊天一类的聊天系统发展日新月异。为了更好充实人们的生活, 特做此系统满足人们在日常生活的需要和需求, 也为了满足人们在信息流通方面的方便, 使人们更能分享互联网上的资源, 使网络的意义更能充分体现。经过了长时间的学习，终于完成了本次课设，本聊天室是使用Java语言完成，在完成过程中经历了许多困难，不过好在网络上有许多大佬的经验。在参考许多大佬的代码与设计思路下，完成了此聊天室，不过还不够完善。目前本聊天系统还有待完善的功能如下: 注册界面相对比较单一, 不够详细, 不能设置个性签名，个人简介等等。 聊天内容不能保存, 退出聊天室之后就找不到之前的聊天内容, 如果在聊天过程中有比较重要的内容需要更慎重的记录。 不能像QQ那样发送图片表情, 而且随意添加在聊天内容的任何位置。 不能让窗口抖动 希望在以后的学习中，能够完善此项目。 " }, { "title": "JAVA-Socket通信 聊天室（工具类）", "url": "/posts/common/", "categories": "课设", "tags": "Java", "date": "2022-06-15 13:02:00 +0000", "snippet": "关于聊天室中工具类部分整体思路把要传输的内容封装成了两个类 Response 和 Request，客户端向服务器发起请求，服务器向客户端回应，通过两个类中包含的请求类型来判断需要进行的操作，传输采用ObjectStream。仔细以看其实会发现，这两个类内容很相似。Requestpublic class Request implements Serializable { private static final long serialVersionUID = -1237018286305074249L; //请求传送的数据类型 private ResponseType type; //请求动作 private String action; //请求域中的数据,key-value private Map&lt;String, Object&gt; attributesMap; public Request(){ this.attributesMap = new HashMap&lt;String, Object&gt;(); } public ResponseType getType() { return type; } public void setType(ResponseType type) { this.type = type; } public String getAction() { return action; } public void setAction(String action) { this.action = action; } public Map&lt;String, Object&gt; getAttributesMap() { return attributesMap; } public Object getAttribute(String name){ return this.attributesMap.get(name); } public void setAttribute(String name, Object value){ this.attributesMap.put(name, value); } public void removeAttribute(String name){ this.attributesMap.remove(name); } public void clearAttribute(){ this.attributesMap.clear(); }}Responsepublic class Response implements Serializable { private static final long serialVersionUID = 1689541820872288991L; //响应状态 private ResponseStatus status; //响应数据类型 private ResponseType type; //响应中的数据，key-value private Map&lt;String,Object&gt; dataMap; //响应输出流 private OutputStream outputStream; public Response(){ this.status = ResponseStatus.OK; this.dataMap = new HashMap&lt;String, Object&gt;(); } public ResponseStatus getStatus() { return status; } public void setStatus(ResponseStatus status) { this.status = status; } public ResponseType getType() { return type; } public void setType(ResponseType type) { this.type = type; } public Map&lt;String, Object&gt; getDataMap() { return dataMap; } public void setDataMap(Map&lt;String, Object&gt; dataMap) { this.dataMap = dataMap; } public OutputStream getOutputStream() { return outputStream; } public void setOutputStream(OutputStream outputStream) { this.outputStream = outputStream; } public void setData(String name, Object value){ this.dataMap.put(name, value); } public Object getData(String name){ return this.dataMap.get(name); } public void removeData(String name){ this.dataMap.remove(name); } public void clearData(){ this.dataMap.clear(); }}在以上两个类中，传输的内容会包括文件和消息，对于文件和消息，我们需要直到发送者和接受者是谁，需要知道发送时间等等，所以同样封装成了两个类。FileInfo用于传送和接收文件//传送文件的工具类public class FileInfo implements Serializable { private static final long serialVersionUID = -5394575332459969403L; //文件接收者 private User toUser; //文件发送者 private User fromUser; //源文件名 private String srcName; //发送时间 private Date sendTime; //目标地IP private String destIp; //目标地端口 private int destPort; //目标文件名 private String destName; public User getToUser() { return toUser; } public void setToUser(User toUser) { this.toUser = toUser; } public User getFromUser() { return fromUser; } public void setFromUser(User fromUser) { this.fromUser = fromUser; } public String getSrcName() { return srcName; } public void setSrcName(String srcName) { this.srcName = srcName; } public Date getSendTime() { return sendTime; } public void setSendTime(Date sendTime) { this.sendTime = sendTime; } public String getDestIp() { return destIp; } public void setDestIp(String destIp) { this.destIp = destIp; } public int getDestPort() { return destPort; } public void setDestPort(int destPort) { this.destPort = destPort; } public String getDestName() { return destName; } public void setDestName(String destName) { this.destName = destName; }}Message用于发送和接收消息public class Message implements Serializable{ private static final long serialVersionUID = 1820192075144114657L; //消息接收者 private User toUser; //消息发送者 private User fromUser; //消息内容 private String message; //消息发送时间 private Date sendTime; public User getToUser() { return toUser; } public void setToUser(User toUser) { this.toUser = toUser; } public User getFromUser() { return fromUser; } public void setFromUser(User fromUser) { this.fromUser = fromUser; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } public Date getSendTime() { return sendTime; } public void setSendTime(Date sendTime) { this.sendTime = sendTime; }}UserUser 类则用于存储用户信息，因为会用于传输，需实现序列化传输。public class User implements Serializable{ private static final long serialVersionUID = 5942011574971970871L; //账号 private long id; //passwd private String password; //昵称 private String nickname; //头像 private int head; //性别 private char sex; public User(String password,String nickname,char sex,int head){ this.password=password; this.sex=sex; this.head=head; if(nickname.equals(\"\")||nickname==null){ this.nickname = \"未命名\"; }else{ this.nickname=nickname; } } public User(long id,String password){ this.id=id; this.password=password; } public long getId(){ return id; } public void setId(long id){ this.id=id; } public void setPassword(String password){ this.password=password; } public String getPassword(){ return this.password; } public void setSex(char sex){ this.sex=sex; } public char getSex(){ return this.sex; } public void setNickname(String nickname){ this.nickname=nickname; } public String getNickname(){ return this.nickname; } public void setHead(){ this.head=head; } public int getHead(){ return this.head; } //获取头像文件 public ImageIcon getHeadIcon(){ ImageIcon image = new ImageIcon(\"images/\"+head+\".png\"); return image; } //生成hash码 @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + head; result = prime * result + (int)(id ^ (id &gt;&gt; 32)); result = prime * result + ((nickname == null) ? 0 : nickname.hashCode()); result = prime * result + ((password == null) ? 0 : password.hashCode()); result = prime * result + sex; return result; } //重写对象比较函数 当且仅当两个对象的头像 账号 性别 昵称 密码 全都相同时 返回true @Override public boolean equals(Object obj) { if(this == obj) return true; if(obj == null) return false; if(getClass() != obj.getClass()) return false; User other = (User) obj; if(head != other.head || id != other.id || sex != other.sex) return false; if(nickname == null){ if(other.nickname != null) return false; }else if(!nickname.equals(other.nickname)) return false; if(password == null){ if(other.password != null) return false; }else if(!password.equals(other.password)) return false; return true; } //转换为string @Override public String toString() { return this.getClass().getName() + \"[id=\" + this.id + \",pwd=\" + this.password + \",nickname=\" + this.nickname + \",head=\" + this.head + \",sex=\" + this.sex + \"]\"; }}ResponseStatus//响应状态枚举public enum ResponseStatus { OK, //请求处理成功 SERVER_ERROR, //服务器内部出错 NOT_FOUND, //请求的资源未找到 BAD_REQUEST //错误的请求对象}ResponseType//响应数据的类型枚举public enum ResponseType { TEXT, //文本内容 TOSENDFILE, //准备发送文件 AGREERECEIVEFILE, //同意接收文件 REFUSERECEIVEFILE, //拒绝接收文件 RECEIVEFILE, //发送文件 LOGIN, //用户登录 LOGOUT, //用户退出 CHAT, //聊天 OTHER, //其他 BOARD, //服务器广播 REMOVE //服务器剔除用户}IOUtilpublic class IOUtil { //关闭字节输入流 public static void close(InputStream is){ if(is != null){ try{ is.close(); }catch (IOException e){ e.printStackTrace(); } } } //关闭字节输出流 public static void close(OutputStream os){ if(os != null){ try{ os.close(); }catch (IOException e){ e.printStackTrace(); } } } //关闭字节输入流和输出流 public static void close(InputStream is,OutputStream os){ close(is); close(os); }}SocketUtilpublic class SocketUtil { //关闭Socket public static void close(Socket socket){ if(socket != null &amp;&amp; !socket.isClosed()){ try{ socket.close(); }catch (IOException e){ e.printStackTrace(); } } } //关闭ServerSocket public static void close(ServerSocket ss){ if(ss != null &amp;&amp; !ss.isClosed()){ try{ ss.close(); }catch (IOException e){ e.printStackTrace(); } } }}" }, { "title": "TCP连接的建立和释放过程详解（三次握手、四次挥手）", "url": "/posts/TCP/", "categories": "笔记", "tags": "计算机网络", "date": "2022-05-29 07:02:00 +0000", "snippet": "1.TCP是基于连接的协议传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。所谓面向连接，是指通信双方在进行通信之前，事先在双方之间建立起一个完整的、可以彼此沟通的通道，这个通道就是连接。TCP是基于连接的协议，也就是说，在正式收发数据之前，必须和对方建立可靠的连接。一个TCP连接的建立要经过三次握手，释放连接一般需要四次挥手。2.连接的建立建立连接的过程一般需要三次握手，如下图所示：在握手之前，主动打开连接的客户端结束CLOSE阶段，被动打开的服务器也结束CLOSE阶段，并进入LISTEN阶段。随后进入三次握手阶段：（1）首先客户端向服务器发送一个SYN包，并等待服务器确认 标志位为SYN，表示请求建立连接 序号为Seq = x（x一般为1） 随后客户端进入SYN-SENT阶段（2）服务器接收到客户端发来的SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文 标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接 序号为Seq = y 确认号为Ack = x + 1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值，随后服务器端进入SYN-RECV阶段（3）客户端接收到发送的SYN + ACK包后，明确了从客户端到服务器的数据传输是正常的，从而结束SYN-SENT阶段。并返回最后一段报文 ​\t标志位为ACK，表示确认收到服务器端同意连接的信号 ​\t序号为Seq = x + 1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值 ​\t确认号为Ack= y + 1，表示收到服务器端序号seq，并将其值加1作为自己的确认号Ack的值 ​\t随后客户端进入ESTABLISHED当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束SYN-RECV阶段，进入ESTABLISHED阶段，从而完成三次握手。 为什么是「三」次握手？ 因为三次是保证client和server端均让对方知道自己具备发送和接收能力的最小次数： client &gt; server：client具备发送能力 server &gt; client：server具备接收和发送能力 client &gt; server：client具备接收能力3.连接的释放释放连接的过程一般需要四次挥手，如下图所示：这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束ESTABLISHED阶段，随后开始四次挥手：（1）首先客户端向服务器发送一段TCP报文表明其想要释放TCP连接 标记位为FIN，表示请求释放连接 序号为Seq = u 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段，并且停止向服务端发送通信数据（2）服务器接收到客户端请求断开连接的FIN报文后，结束ESTABLISHED阶段，进入CLOSE-WAIT阶段并返回一段TCP报文 标记位为ACK，表示接收到客户端释放连接的请求 序号为Seq = v 确认号为Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加1作为本段报文确认号Ack的值 随后服务器开始准备释放服务器端到客户端方向上的连接客户端收到服务器发送过来的TCP报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端进入FIN-WAIT-2阶段。（3）服务器端在发出ACK确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过CLOSE-WAIT阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段TCP报文 标记位为FIN和ACK，表示已经准备好释放连接了 序号为Seq = w 确认号Ack = u + 1，表示是在收到客户端报文的基础上，将其序号Seq的值加1作为本段报文确认号Ack的值随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段，并且停止向*客户端发送数据*。（4）客户端收到从服务器发来的TCP报文，确认了服务器已经做好释放连接的准备，于是进入TIME-WAIT阶段，并向服务器发送一段报文 标记位为ACK，表示接收到服务器准备好释放连接的信号 序号为Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack值作为本段序号的值 确认号为Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号Seq的值作为本段报文确认号的值随后客户端开始在TIME-WAIT阶段等待2 MSL。服务器端收到从客户端发出的TCP报文之后进入CLOSED阶段，由此正式确认管关闭服务器端到客户端方向上的连接。客户端等待完2 MSL之后，进入CLOSED阶段，由此完成四次挥手。 为什么是「四」次挥手？ 因为TCP是一个全双工协议，必须单独拆除每一条信道，两个方向的接收、发送都需要单独关闭。" }, { "title": "socket简介", "url": "/posts/tcp-udp/", "categories": "笔记", "tags": "计算机网络", "date": "2022-04-15 13:02:00 +0000", "snippet": "1：socket大致介绍socket编程是一门技术，它主要是在网络通信中经常用到既然是一门技术，由于现在是面向对象的编程，一些计算机行业的大神通过抽象的理念，在现实中通过反复的理论或者实际的推导，提出了抽象的一些通信协议，基于tcp/ip协议，提出大致的构想，一些泛型的程序大牛在这个协议的基础上，将这些抽象化的理念接口化，针对协议提出的每个理念，专门的编写制定的接口，与其协议一一对应，形成了现在的socket标准规范，然后将其接口封装成可以调用的接口，供开发者使用目前，开发者开发出了很多封装的类来完善socket编程，都是更加方便的实现刚开始socket通信的各个环节，所以我们首先必须了解socket的通信原理，只有从本质上理解socket的通信，才可能快速方便的理解socket的各个环节，才能从底层上真正的把握2：TCP/IP协议要理解socket必须的得理解tcp/ip，它们之间好比送信的线路和驿站的作用，比如要建议送信驿站，必须得了解送信的各个细节。TCP/IP协议不同于iso的7个分层，它是根据这7个分层，将其重新划分，好比打扫卫生，本来有扫帚，垃圾斗，抹布，涂料，盆栽等就好比OSI的标准几个分层，tcp/ip根据用途和功能，将扫帚，垃圾斗放到粗略整理层，抹布涂料放到中度整理层，盆栽放到最终效果层。这里TCP/IP也对OSI的网络模型层进行了划分：大致如下：OSI模型：TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等传输层：TCP，UDP网络层：IP，ICMP，OSPF，EIGRP，IGMP数据链路层：SLIP，CSLIP，PPP，MTU每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的通过上面的图形，由于底一层的需要向高一层的提供服务，我们大致的理解应用程序需要传输层的tcp和网络层的ip协议提供服务，但是我们这章要分析的socket它是在tcpip协议的那一部分呢，就好比，我们的通讯线路已经有明确的规定，我们的驿站要设计在哪个地方一样3：回过头再来理解socket到目前为止，大致的了解了应用程序和tcpip协议的大致关系，我们只是知道socket编程是在tcp/IP上的网络编程，但是socket在上述的模型的什么位置呢。这个位置被一个天才的理论家或者是抽象的计算机大神提出并且安排出来我们可以发现socket就在应用程序的传输层和应用层之间，设计了一个socket抽象层，传输层的底一层的服务提供给socket抽象层，socket抽象层再提供给应用层，问题又来了，应用层和socket抽象层之间和传输层，网络层之间如何通讯的呢，了解这个之前，我们还是回到原点要想理解socket编程怎么通过socket关键词实现服务器和客户端通讯，必须得实现的了解tcp/ip是怎么通讯的，在这个的基础上在去理解socket的握手通讯在tcp/ip协议中，tcp通过三次握手建立起一个tcp的链接，大致如下第一次握手：客户端尝试连接服务器，向服务器发送syn包，syn=j，客户端进入SYN_SEND状态等待服务器确认第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手三次握手如下图：根据tcp的三次握手，socket也定义了三次握手，也许是参考tcp的三次握手，一些计算机大神们画出了socket的三次握手的模型图模型图如下：在上面图的基础上，如果我们得到上面的图形，需要我们自己开发一些接口，来满足上面的通讯的三次握手，问题就出来了，我们会需要开发哪些函数4：socket的一些接口函数原理通过上面的图，我们清楚，我们好比一些泛型的程序员，一些理论提供者提供给了我们上面的图形的理论，我们需要做的就是讲上面的图形的抽象化的东西具体化第一次握手：客户端需要发送一个syn j 包，试着去链接服务器端，于是客户端我们需要提供一个链接函数第二次握手：服务器端需要接收客户端发送过来的syn J+1 包，然后在发送ack包，所以我们需要有服务器端接受处理函数第三次握手：客户端的处理函数和服务器端的处理函数三次握手只是一个数据传输的过程，但是，我们传输前需要一些准备工作，比如将创建一个套接字，收集一些计算机的资源，将一些资源绑定套接字里面，以及接受和发送数据的函数等等，这些功能接口在一起构成了socket的编程下面大致的按照客户端和服务端将所需的函数详细的列举出来上面的两个图都概述了socket的通讯原理。5：socket的一个例子，总结上述的问题详细就不在说明，通过一段代码详细的解释(使用python实现)。TCP客户端import socketimport timedef create_client(server_host_and_port: tuple, data_size: int, data_type: str): \"\"\" 创建客户端 :param server_host_and_port: 服务器IP及端口 :param data_size: 传输字节大小 :param data_type: 编解码类型 :return: \"\"\" try: # 创建客户端socket对象，模式为TCP client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 连接服务器 client.connect(server_host_and_port) # 退出标致 exit_flag = 0 while not exit_flag: # 输入要发送的内容 send_data = input('请输入要发送的字符：') # 编码并发送内容 client.send(send_data.encode(data_type)) # 接收内容并解码 receive_data = client.recv(data_size).decode(data_type) if receive_data == 'exit': exit_flag = 1 else: # 打印服务器返回的内容 print('[{}]接收到来自服务器的消息：{}'.format(time.asctime(), receive_data)) except Exception as e: print(e) raise eif __name__ == '__main__': create_client(('127.0.0.1', 8888), 1024, 'utf-8')TCP服务器import socketimport timedef create_server(hostAndPort: tuple, data_size: int, data_type: str, connect_max: int): \"\"\" 创建服务器 :param hostAndPort: 本机IP和开放端口 :param data_size: 最大传输字节 :param data_type: 编解码格式 :param connect_max: 最大连接数 :return: \"\"\" try: # 创建服务器socket 对象，模式为TCP server = socket.socket( socket.AF_INET, socket.SOCK_STREAM # TCP ) # 绑定主机IP与端口 server.bind(hostAndPort) # 设置最大连接数 server.listen(connect_max) # 退出标致 exit_flag = 0 while True: print('等待连接。。。', end='') # 接收套接字对象与地址 client_socket, add = server.accept() print('\\r[{}]{}连接成功！'.format(time.asctime(), add)) while not exit_flag: # 接收内容，并解码，若客户端异常退出，放弃此客户端 try: receiver_data = client_socket.recv(data_size).decode(data_type) except ConnectionResetError: print('[{}]{}异常退出！'.format(time.asctime(), add)) break # 退出标致 if receiver_data == 'exit': exit_flag = 1 client_socket.send('exit'.encode(data_type)) print('[{}]{}已退出'.format(time.asctime(), add)) else: # 打印接收的内容 print('[{}]接收到来自{}的内容：{}'.format(time.asctime(), add, receiver_data)) # 将字母全部转为大写 send_data = receiver_data.upper() # 利用客户端套接字对象发送给客户端 client_socket.send(send_data.encode(data_type)) # 打印发送的内容 print('已发送给{}内容：{}'.format(add, send_data)) except Exception as e: raise eif __name__ == '__main__': create_server(('127.0.0.1', 8888), 1024, 'utf-8', 5)UDP客户端import socket# 服务器IP和开放端口server_host_port = ('127.0.0.1', 8888)# 本地IP和开放端口client_host_port = ('127.0.0.1', 8889)# 最大传输字节data_size = 1024# 编解码格式data_type = 'utf-8'def create_client(): client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) client.bind(client_host_port) try: while True: send_data = input('请输入要发送的字符：') # 发送内容 client.sendto(send_data.encode(data_type), server_host_port) # 接收内容 receive_data, add = client.recvfrom(data_size) print('接收到来自{}的消息：{}'.format(add, receive_data.decode(data_type))) except Exception as e: print(e)create_client()UDP服务器import socket# 本机IP和开放端口host_port = ('127.0.0.1', 8888)# 最大传输字节data_size = 1024# 编解码格式data_type = 'utf-8'# 最大连接数connect_max = 5def create_server(): try: # 创建socket对象 server = socket.socket( socket.AF_INET, socket.SOCK_DGRAM # UDP ) # 绑定主机IP与端口 server.bind(host_port) while True: # data为接收数据，add为发送者地址 receiver_data, add = server.recvfrom(data_size) receiver_data = receiver_data.decode(data_type) print('接收到来自{}的内容：{}'.format(add, receiver_data)) # 将字母全部转为大写 send_data = receiver_data.upper() # 发送给客户端 server.sendto(send_data.encode(data_type), add) print('已发送给{}内容：{}'.format(add, send_data)) except Exception as e: print(e)create_server()" }, { "title": "数据结构模板", "url": "/posts/data-structure/", "categories": "笔记", "tags": "算法", "date": "2022-04-15 03:48:00 +0000", "snippet": "本篇文章旨在介绍基础数据结构模板。算法竞赛中，利用指针的数据结构跑的太慢，故使用数组来表示的数据结构包括：单链表 双链表 栈 队列 单调栈 单调队列 KMP Trie树 并查集 堆 一般哈希 字符串哈希单链表// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init(){ head = -1; idx = 0;}// 在链表头插入一个数avoid insert(int a){ e[idx] = a, ne[idx] = head, head = idx ++ ;}// 将头结点删除，需要保证头结点存在void remove(){ head = ne[head];}双链表// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init(){ //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2;}// 在节点a的右边插入一个数xvoid insert(int a, int x){ e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ;}// 删除节点avoid remove(int a){ l[r[a]] = l[a]; r[l[a]] = r[a];}栈// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt &gt; 0){}队列普通队列// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh &lt;= tt){}循环队列// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt){}单调栈常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ ){ while (tt &amp;&amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i;}单调队列常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ ){ while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i;}KMP// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ ){ while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j;}// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ ){ while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 }}Trie树int son[N][26], cnt[N], idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str){ int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ;}// 查询字符串出现的次数int query(char *str){ int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p];}并查集(1)朴素并查集： int p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b);(2)维护size的并查集： int p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： size[find(b)] += size[find(a)]; p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集： int p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i &lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量堆// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b){ swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);}void down(int u){ int t = u; if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); }}void up(int u){ while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) { heap_swap(u, u / 2); u &gt;&gt;= 1; }}// O(n)建堆for (int i = n / 2; i; i -- ) down(i);一般哈希(1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; }(2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; }字符串哈希核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ ){ h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P;}// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r){ return h[r] - h[l - 1] * p[r - l + 1];}" }, { "title": "飞机大战", "url": "/posts/plane-war/", "categories": "课设", "tags": "Game", "date": "2022-04-15 02:48:00 +0000", "snippet": "一、设计选题《飞机大战》二、课题简介飞机大战是由腾讯公司的微信团队开发的一款微信小游戏，这款游戏以太空主题的画面为游戏背景，由玩家控制飞机，发射炮弹击毁敌方飞机。画面简洁有趣，规则简单易懂，操作便捷易上手。这款游戏不同于腾讯开发的以盈利为目标的其他游戏，抛去了现在游戏的花里胡哨，回归了游戏最简单的目的，仅仅是为了好玩，没有门槛，没有引导用户充钱。让我们们都能够找到童年玩掌机类游戏的乐趣。不过可惜《飞机大战》已经被淘汰，所以在这重现飞机大战，表达对现在国内缺乏真正让人快乐的游戏的惋惜和对这款经典游戏的致敬。并且希望国内的游戏市场能够变得更好，也能让更多的人可以改变对游戏的偏见，让大家能够真正感受到这第九大艺术的魅力。三、运行环境Windows系统，PyCharmPygame,random,os四、具体实现1. 架构设计系统架构如图1所示。下面分别介绍各个部分的作用及功能：game.py，游戏主模块，封装Game类并负责启动游戏。game_hud.py，游戏面板模块，封装指示器面板类。game_items.py，游戏元素模块，封装英雄飞机，子弹，敌机，道具等游戏元素类，并定义全局变量。game_music.py，游戏音乐模块，封装音乐播放器类。font，放置游戏中使用的字体素材。images，放置了游戏中使用的图片素材。sound，放置了游戏中使用的声音素材。2. 核心功能实现class Game(object): # 游戏类 def __init__(self): # 游戏主窗口 self.main_window = pygame.display.set_mode(SCREEN_RECT.size) pygame.display.set_caption(\"飞机大战\") # 游戏状态 self.is_game_over = False self.is_pause = False # 精灵组属性 self.all_group = pygame.sprite.Group() # 所有精灵组 self.enemies_group = pygame.sprite.Group() # 敌机精灵组 self.supplies_group = pygame.sprite.Group() # 道具精灵组 # 创建精灵 # 背景精灵，交替滚动 self.all_group.add(Background(False), Background(True)) # 指示器面板 self.hud_panel = HudPanel(self.all_group) # 创建敌机 self.create_enemies() # 英雄精灵 self.hero = Hero(self.all_group) # 设置面板中炸弹数量 self.hud_panel.show_bomb(self.hero.bomb_count) # 创建道具 self.create_supplies() # 创建音乐播放器 self.player = MusicPlayer(\"game_music.wav\") self.player.play_music() def reset_game(self): # 重置游戏 self.is_game_over = False self.is_pause = False self.hud_panel.reset_panel() # 设置英雄的初始位置 self.hero.rect.midbottom = HERO_DEFAULT_MID_BOTTOM # 清空所有敌机 for enemy in self.enemies_group: enemy.kill() # 清空残留子弹 for bullet in self.hero.bullets_group: bullet.kill() # 重新创建敌机 self.create_enemies() def event_handler(self): # 监听事件：return：如果监听到退出事件，返回True，否则给、返回False for event in pygame.event.get(): if event.type == pygame.QUIT: return True elif event.type == pygame.KEYDOWN and (event.key == pygame.K_ESCAPE or event.key == pygame.K_SPACE): if self.is_game_over: # 游戏已经结束 self.reset_game() # 重新开始游戏 else: self.is_pause = not self.is_pause # 切换暂停状态 self.player.pause_music(self.is_pause) \"\"\"以下为开发者按钮\"\"\" if event.type == pygame.KEYDOWN and event.key == pygame.K_l: self.hud_panel.lives_count += 1 self.hud_panel.show_lives() elif event.type == pygame.KEYDOWN and event.key == pygame.K_i: if self.hero.is_power==False: self.hero.is_power = True else: self.hero.is_power = False elif event.type == pygame.KEYDOWN and event.key == pygame.K_a: self.hero.bomb_count += 1 self.hud_panel.show_bomb(self.hero.bomb_count) elif event.type == pygame.KEYDOWN and event.key == pygame.K_n: if self.hero.bullets_kind == 0: self.hero.bullets_kind = 1 else: self.hero.bullets_kind = 0 \"\"\"结束\"\"\" # 判断是否正在游戏 if not self.is_game_over and not self.is_pause: # 监听发射子弹事件 if event.type ==HERO_FIRE_EVENT: self.player.play_sound(\"bullet.wav\") self.hero.fire(self.all_group) # 监听关闭子弹增强事件 if event.type == BULLET_ENHANCED_OFF_EVENT: self.hero.bullets_kind = 0 pygame.time.set_timer(BULLET_ENHANCED_OFF_EVENT, 0) # 监听投放道具事件 if event.type == THROW_SUPPLY_EVENT: self.player.play_sound(\"supply.wav\") supply = random.choice(self.supplies_group.sprites()) supply.throw_supply() # 监听英雄牺牲事件 if event.type == HERO_DEAD_EVENT: print(\"英雄牺牲了...\") # 生命计数 -1 self.hud_panel.lives_count -= 1 # 更新生命计数显示 self.hud_panel.show_lives() if self.hud_panel.lives_count &gt; 0: # 设置英雄回到的初始位置 self.hero.rect.midbottom = HERO_DEFAULT_MID_BOTTOM # 开启无敌模式 self.hero.is_power = True # 更新炸弹显示 self.hud_panel.show_bomb(self.hero.bomb_count) # 监听取消英雄无敌事件 if event.type == HERO_POWER_OFF_EVENT: print(\"取消无敌状态...\") # 设置英雄属性 self.hero.is_power = False # 取消定时器 pygame.time.set_timer(HERO_POWER_OFF_EVENT, 0) # 监听玩家按下b，引爆一颗炸弹 if event.type == pygame.KEYDOWN and event.key == pygame.K_b: # 如果英雄没有牺牲同时有炸弹 if self.hero.hp &gt; 0 and self.hero.bomb_count &gt; 0: self.player.play_sound(\"use_bomb.wav\") # 引爆炸弹 score = self.hero.blowup(self.enemies_group) # 更新炸弹数量显示 self.hud_panel.show_bomb(self.hero.bomb_count) # 更新游戏得分，如果游戏等级提升，创建新的敌机 if self.hud_panel.increase_score(score): self.create_enemies() return False def start(self): # 开始游戏 clock = pygame.time.Clock() # 游戏时钟 frame_counter = 0 # 逐帧动画计数器 while True: # 生命计数等于 0，表示游戏结束 self.is_game_over = self.hud_panel.lives_count == 0 if self.event_handler(): # 事件监听 self.hud_panel.save_best_score() return # 判断游戏状态 if self.is_game_over: self.hud_panel.panel_pause(True, self.all_group) elif self.is_pause: self.hud_panel.panel_pause(False, self.all_group) else: # 获得当前时刻的按键元组 keys = pygame.key.get_pressed() # 水平移动基数 move_hor = keys[pygame.K_RIGHT] - keys[pygame.K_LEFT] # 垂直移动基数 move_ver = keys[pygame.K_DOWN] - keys[pygame.K_UP] # 修改逐帧动画计数器 frame_counter = (frame_counter + 1) % FRAME_INTERVAL # 更新 all_group 中所有精灵内容 self.all_group.update(frame_counter == 0, move_hor, move_ver) self.hud_panel.panel_resume(self.all_group) # 碰撞检测 self.check_collide() # 绘制 all_group 中的所有精灵 self.all_group.draw(self.main_window) pygame.display.update() # 更新显示 clock.tick(60) # 设置刷新帧率 def create_enemies(self): # 根据游戏级别创建不同数量的敌机 # 敌机精灵组中的精灵数量 count = len(self.enemies_group.sprites()) # 要添加到的精灵组 groups = (self.all_group, self.enemies_group) # 判断游戏级别及已有的敌机数量 if self.hud_panel.level == 1 and count == 0: # 关卡 1 for i in range(16): Enemy(0, 3, *groups) elif self.hud_panel.level == 2 and count == 16: # 关卡 2 # 增加敌机的最大速度 for enemy in self.enemies_group.sprites(): enemy.max_speed = 5 # 创建敌机 for i in range(8): Enemy(0, 5, *groups) for i in range(2): Enemy(1, 1, *groups) elif self.hud_panel.level == 3 and count == 26: # 关卡 3 # 增加敌机的最大速度 for enemy in self.enemies_group.sprites(): enemy.max_speed = 7 if enemy.kind == 0 else 3 # 创建敌机 for i in range(8): Enemy(0, 7, *groups) for i in range(2): Enemy(1, 3, *groups) for i in range(2): Enemy(2, 1, *groups) def check_collide(self): \"\"\"碰撞检测\"\"\" # 检测英雄飞机和敌机的碰撞 collide_enemies = pygame.sprite.spritecollide(self.hero, self.enemies_group, False, pygame.sprite.collide_mask) if not self.hero.is_power: enemies = pygame.sprite.spritecollide(self.hero, self.enemies_group, False, pygame.sprite.collide_mask) enemies = list(filter(lambda x : x.hp &gt; 0,enemies)) if enemies: self.player.play_sound(self.hero.wav_name) self.hero.hp = 0 for enemy in collide_enemies: enemy.hp = 0 # 摧毁发生碰撞的敌机 # 检测敌机被子弹击中 hit_enemies = pygame.sprite.groupcollide(self.enemies_group, self.hero.bullets_group, False, False, pygame.sprite.collide_mask) # 遍历字典 for enemy in hit_enemies: # 已经被摧毁的敌机不需要浪费子弹 if enemy.hp &lt;= 0: continue # 遍历击中敌机的子弹列表 for bullet in hit_enemies[enemy]: # 将子弹从所有精灵组中清除 bullet.kill() # 修改敌机的生命值 enemy.hp -= bullet.damage # 如果敌机没有被摧毁，继续下一颗子弹 if enemy.hp &gt; 0: continue # 修改游戏得分并判断是否升级 if self.hud_panel.increase_score(enemy.value): # 播放升级音效 self.player.play_sound(\"upgrade.wav\") self.create_enemies() # 播放敌机炸弹音效 self.player.play_sound(enemy.wav_name) # 退出遍历子弹列表循环 break # 英雄拾取道具 supplies = pygame.sprite.spritecollide(self.hero, self.supplies_group, False, pygame.sprite.collide_mask) if supplies: supply = supplies[0] # 播放使用道具音效 self.player.play_sound(supply.wav_name) # 将道具设置到游戏窗口下方 supply.rect.y = SCREEN_RECT.h # 判断道具类型 if supply.kind == 0: # 炸弹补给 self.hero.bomb_count += 1 self.hud_panel.show_bomb(self.hero.bomb_count) else: # 设置子弹增强 self.hero.bullets_kind = 1 # 设置关闭子弹增强的定时器事件 pygame.time.set_timer(BULLET_ENHANCED_OFF_EVENT, 8000) def create_supplies(self): \"\"\"创建道具\"\"\" Supply(0, self.supplies_group, self.all_group) Supply(1, self.supplies_group, self.all_group) # 设置 30s 投放道具定时器事件 pygame.time.set_timer(THROW_SUPPLY_EVENT, 10000)if __name__ == '__main__': pygame.init() Game().start() pygame.quit()五.项目演示六、心得体会Python的计算生态很强大，通过pygame可以很轻松的设计出一款2D游戏，通过此次课程设计，我初步理解了面向对象的思想，感受到了使用python语言进行游戏项目开发的乐趣。当游戏能够运行时，心中便会有一种成就感。希望以后可以灵活的掌握运用面向对象的编程技巧，并且能将其运用到python程序的实际开发中。源码资源可在这找到：https://github.com/Aye486/scaling-adventure.git" }, { "title": "搜索与图论模板", "url": "/posts/Search-and-Graph-Theory/", "categories": "笔记", "tags": "算法", "date": "2022-04-15 02:48:00 +0000", "snippet": "本篇文章旨在介绍搜索与图论模板。包括：树与图的存储，拓扑排序，朴素dijkstra，堆优化版dijkstra，Bellman-Ford算法，spfa 算法（队列优化的Bellman-Ford算法），spfa判断图中是否存在负环，floyd算法，朴素版prim算法，Kruskal算法，染色法判别二分图，匈牙利算法树与图的存储// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}// 初始化idx = 0;memset(h, -1, sizeof h);树与图的遍历深度优先搜索(dfs)int dfs(int u){ st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); }}广度优先搜索(bfs)queue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size()){ int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } }}拓扑排序bool topsort(){ int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i &lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh &lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1;}最短路算法朴素dijkstraint g[N][N]; // 存储每条边int dist[N]; // 存储1号点到每个点的最短距离bool st[N]; // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];}堆优化版dijkstratypedef pair&lt;int, int&gt; PII;int n; // 点的数量int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边int dist[N]; // 存储所有点到1号点的距离bool st[N]; // 存储每个点的最短距离是否已确定// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];}Bellman-Ford算法注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。int n, m; // n表示点数，m表示边数int dist[N]; // dist[x]存储1到x的最短路距离struct Edge // 边，a表示出点，b表示入点，w表示边的权重{ int a, b, w;}edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i &lt; n; i ++ ) { for (int j = 0; j &lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] &gt; dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; return dist[n];}spfa 算法（队列优化的Bellman-Ford算法）int n; // 总点数int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边int dist[N]; // 存储每个点到1号点的最短距离bool st[N]; // 存储每个点是否在队列中// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa(){ memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n];}spfa判断图中是否存在负环int n; // 总点数int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数bool st[N]; // 存储每个点是否在队列中// 如果存在负环，则返回true，否则返回false。bool spfa(){ // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false;}floyd算法(多源最短路)初始化： for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){ for (int k = 1; k &lt;= n; k ++ ) for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}最小生成树算法朴素版prim算法int n; // n表示点数int g[N][N]; // 邻接矩阵，存储所有边int dist[N]; // 存储其他点到当前最小生成树的距离bool st[N]; // 存储每个点是否已经在生成树中// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim(){ memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i &lt; n; i ++ ) { int t = -1; for (int j = 1; j &lt;= n; j ++ ) if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (i &amp;&amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res;}Kruskal算法int n, m; // n是点数，m是边数int p[N]; // 并查集的父节点数组struct Edge // 存储边{ int a, b, w; bool operator&lt; (const Edge &amp;W)const { return w &lt; W.w; }}edges[M];int find(int x) // 并查集核心操作{ if (p[x] != x) p[x] = find(p[x]); return p[x];}int kruskal(){ sort(edges, edges + m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt &lt; n - 1) return INF; return res;}染色法判别二分图int n; // n表示点数int h[N], e[M], ne[M], idx; // 邻接表存储图int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色// 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c){ color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true;}bool check(){ memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i &lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag;}匈牙利算法int n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过bool find(int x){ for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false;}// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点int res = 0;for (int i = 1; i &lt;= n1; i ++ ){ memset(st, false, sizeof st); if (find(i)) res ++ ;}" }, { "title": "你好，世界！", "url": "/posts/hello-world/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "感谢关注～//代码片段int main(){ hello world;}" } ]
