<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Aye486</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2022-06-25T14:28:47+00:00</updated> <author> <name>Aye486</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Aye486 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>协程简介</title><link href="/posts/%E5%8D%8F%E7%A8%8B%E5%92%8Clibco/" rel="alternate" type="text/html" title="协程简介" /><published>2022-06-25T13:02:00+00:00</published> <updated>2022-06-25T14:26:38+00:00</updated> <id>/posts/%E5%8D%8F%E7%A8%8B%E5%92%8Clibco/</id> <content src="/posts/%E5%8D%8F%E7%A8%8B%E5%92%8Clibco/" /> <author> <name>Aye486</name> </author> <category term="笔记" /> <summary> 基本概念 协程 在这里略过进程和线程的基本概念，默认读者了解 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程那样需要上下文切换来消耗资源（用户态和内核态的切换），因此协程的开销远远小于线程的开销。 协程本质上就是用户态线程，将调度的代码在用户态重新实现。因为子程序切换不是线程切换而是由程序自身控制，没有线程切换的开销，所以协程有极高的执行效率。协程通常是纯软件实现的多任务，与CPU和操作系统通常没有关系，跨平台，跨体系架构。 协程在执行过程中，可以调用别的协程自己则中途退出执行，之后又从调用别的协程的地方恢复执行。这有点像操作系统的线程，执行过程中可能被挂起，让位于别的线程执行，稍后又从挂起的地方恢复执行。 对于线程而言，其上下文存储在内核栈上。线程的上下文切换必须先进入内核态... </summary> </entry> <entry><title>JAVA-Socket通信 聊天室（客户端）</title><link href="/posts/client/" rel="alternate" type="text/html" title="JAVA-Socket通信 聊天室（客户端）" /><published>2022-06-15T13:02:00+00:00</published> <updated>2022-06-25T14:19:58+00:00</updated> <id>/posts/client/</id> <content src="/posts/client/" /> <author> <name>Aye486</name> </author> <category term="课设" /> <summary> 关于聊天室中客户端部分 整体思路 客户端的代码用到的类如上所示，其中 entity 中的两个类仅用于界面，所以不会进行介绍。 Thread 客户端线程，一个线程表示一个用户，处理服务器发来的消息，在里面用了 currentFrame 这个变量来表示当前窗口。 //客户端线程 监听服务器发送过来的信息 public class Thread extends Thread { //当前窗体 private JFrame currentFrame; public ClientThread(JFrame frame){ currentFrame = frame; } public void run() { try { //客户端与服务器处于连接状态 wh... </summary> </entry> <entry><title>JAVA-Socket通信 聊天室（服务端）</title><link href="/posts/Service/" rel="alternate" type="text/html" title="JAVA-Socket通信 聊天室（服务端）" /><published>2022-06-15T13:02:00+00:00</published> <updated>2022-06-17T07:30:52+00:00</updated> <id>/posts/Service/</id> <content src="/posts/Service/" /> <author> <name>Aye486</name> </author> <category term="课设" /> <summary> 关于聊天室中服务器部分 一个聊天室，我们可以将其分为服务端和客户端，而通信的简易过程如下图所示 对于服务器，我们需要做的是1、验证用户登陆信息。2、接收用户发送的信息并转发给目标用户 整体思路 Server端 UserService 用于用户账号管理，预先创建几个账号，然后存到文件中，每次服务器执行时，都会将文件中的账号信息读入，同时新创建的用户账号也会存入到文件中去。 public class UserService { private static int idCount =3;//id //新增用户 public void addUser(User user){ user.setId(++idCount); List&amp;lt;User&amp;gt; users = loadAllUser(); ... </summary> </entry> <entry><title>JAVA-Socket通信 聊天室</title><link href="/posts/chartroom/" rel="alternate" type="text/html" title="JAVA-Socket通信 聊天室" /><published>2022-06-15T13:02:00+00:00</published> <updated>2022-06-17T03:50:21+00:00</updated> <id>/posts/chartroom/</id> <content src="/posts/chartroom/" /> <author> <name>Aye486</name> </author> <category term="课设" /> <summary> 聊天室曾经盛行一时，今天我们就用简单的java代码来复刻他。 一、项目名称 聊天室 二、功能介绍 用Java图形用户界面编写聊天室服务器端和客户端， 支持多个客户端连接到一个服务器。每个客户端能够输入账号，包括注册功能。 可以实现群聊（聊天记录显示在所有客户端界面）。 完成好友列表在各个客户端上显示，包括头像和用户名。 可以实现私人聊天，用户可以选择某个其他用户，单独发送信息，同时实现了文件传输。 服务器能够群发系统消息，能够对用户私发消息，能够强行让某些用户下线。 客户端的上线下线要求能够在其他客户端上面实时刷新。 服务器能够查看在线用户和注册用户 三、模块功能 服务器与客户端之间的交互简图 服务器与客户端的功能缩略图 具体框架 Client... </summary> </entry> <entry><title>JAVA-Socket通信 聊天室（工具类）</title><link href="/posts/common/" rel="alternate" type="text/html" title="JAVA-Socket通信 聊天室（工具类）" /><published>2022-06-15T13:02:00+00:00</published> <updated>2022-06-16T14:32:41+00:00</updated> <id>/posts/common/</id> <content src="/posts/common/" /> <author> <name>Aye486</name> </author> <category term="课设" /> <summary> 关于聊天室中工具类部分 整体思路 把要传输的内容封装成了两个类 Response 和 Request，客户端向服务器发起请求，服务器向客户端回应，通过两个类中包含的请求类型来判断需要进行的操作，传输采用ObjectStream。仔细以看其实会发现，这两个类内容很相似。 Request public class Request implements Serializable { private static final long serialVersionUID = -1237018286305074249L; //请求传送的数据类型 private ResponseType type; //请求动作 private String action; //请求域中的数据,key-value private Map&amp;lt;S... </summary> </entry> </feed>
